# 11. 句法扩展和模块

本章描述了 Chez Scheme 对 `syntax-case` 句法抽象机制所做的扩展，这些扩展现已被 R^6RS 报告所标准化。这些扩展包括模块系统（11.5 节）、元定义（11.8 节）、可以作为`syntax-rules` 防护板的按情况展开（11.9 节）、`fluid-let-syntax` 以及 `include` 。


## 11.1 fluid 关键字绑定

通过 R^6RS 报告中的 `define-syntax`、`let-syntax` 以及 `letrec-syntax` 形式定义的关键字绑定，可以使用 `fluid-let-syntax` 临时地重新绑定。

+ 语法：`(fluid-let-syntax ((keyword expr) ...) form1 form2 ...) `
+ 返回：参考解释
+ 库：`(chezscheme)`

每一条 `expr` 必须求值为一个转换器。`fluid-let-syntax` 类似于标准的 `let-syntax`，只不过不会引入关键字 `keyword ...` 的新绑定，`fluid-let-syntax` 会在展开它的程序体的时候，临时修改关键字已有的绑定。也就是说，在展开 `form1 form2 ...` 的时候，每个关键字可见的（或最高层）词法绑定被临时地替换为一个新的关联——即一个关键字与其对应的转换器。这会影响对解析为相同词法（或顶级）绑定的关键字的任何引用，无论引用是在出现在程序体正文还是在展开时引入。相反，`let-syntax` 仅捕获出现在程序体正文中的那些引用。

> #TBD, DeathKing  
> body 要如何翻译？  
> + 显然不是“语句体”，因为 Scheme 中没有语句（statement）这个说法；  
> + 显然也不是“过程体”，因为这里是待展开的形式；  
> + 这里没有使用 `<body>` 这个语法记号，因此也不适宜保留 `<body>` 这样的形式；  
> + 暂时使用“程序体”的说法，如果有更好的说法，稍后会修改。

下面的例子展示了 `fluid-let-syntax` 和 `let-syntax` 的不同：

```scheme
(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([g (syntax-rules ()
                    [(_ x) (f x)])])
    (let-syntax ([f (syntax-rules ()
                      [(_ x) x])])
      (g 1)))) ; => 2 

(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([g (syntax-rules ()
                    [(_ x) (f x)])])
    (fluid-let-syntax ([f (syntax-rules ()
                            [(_ x) x])])
      (g 1)))) ; => 1
```

除了在第二条表达式中，`let-syntax` 形式内部表达式中第一条表达式是 `fluid-let-syntax` 形式，这两条表达式都是相同的。在第一条表达式中，出现在展开 `(g 1)` 过程中的 `f` 引用的是由 `let` 式所绑定的变量 `f`， 而在第二条表达式中的 `f` 引用的是由 `fluid-let-syntax` 所绑定的关键字 `f`。

下面的例子利用 `fluid-let-syntax` 来定义 `define-integrable` 形式，后者类似于用于过程定义的 `define`，但无论在何处直接调用该过程，都导致过程的代码被集成或插入到该位置 #TBD。通过 `define-integrable` 或 `define` 来定义的过程没有语义差异，只不过在最高层， `define-integrable` 形式必须在首次引用所定义的标识符之前出现。词法作用域被保持了，集成调用中的实际参数只在适当的时间求值一次，可集成过程可以用作第一类值，并且递归过程不会导致无限递归扩展。

```scheme
(define-syntax define-integrable
  (syntax-rules (lambda)
    [(_ name (lambda formals form1 form2 ...))
     (begin
       (define xname
         (fluid-let-syntax ([name (identifier-syntax xname)])
           (lambda formals form1 form2 ...)))
       (define-syntax name
         (lambda (x)
           (syntax-case x ()
             [_ (identifier? x) #'xname]
             [(_ arg (... ...))
              #'((fluid-let-syntax ([name (identifier-syntax xname)])
                   (lambda formals form1 form2 ...))
                  arg
                  (... ...))]))))]))
```

`define-integrable` 的语法如下：

```
(define-integrable name lambda-expression)
```

`define-integrable` 形式会被展开为一个由定义构成的序对：关于 `name` 的句法定义以及关于 `xname` 的变量定义 #TBD。跟 `name` 对应的转换器将对于 `name` 的调用展开为对 `lambda`-表达式的直接调用。由于展开的结果仅仅是直接的 `lambda` 应用（等价于 `let` 表达式），因此在求值过程的体之前，实际参数只会刚好被求值一次，正如所要求的那样。所有指向 `name` 的引用都会被指向 `xname` 的引用所替代。`xname` 的定义将其绑定到 `lambda`表达式的值上。这使得该过程可以被用作第一类值。由于 `xname` 是由转换器引入的，因此除了由 `name` 对应的转换器引入的对其的引用，`xname` 的绑定在其它任何地方都是不可见的。

无论 `lambda`-表达式出现在何处，在其内部 `name` 都被重新绑定到一个转换器上，将所有的 `name` 展开为对 `xname` 的引用。以这样的目的使用 `fluid-let-syntax` 可以防止在可集成过程中间接递归的无限展开。 这允许过程可以递归调用而不会导致无限扩展。 `define-integrable` 没有特意维护词法作用域，这是因为词法作用域由展开器自动维护。

Chez Scheme 在适当时自动集成本地定义的过程。但是，它无法集成最高层定义的过程，因为可以随时（通过eval或load）将为最高层变量的赋值代码引入系统。即使本地绑定过程的集成留给编译器，`define-integrable` 可用于强制集成在最高层的定义的过程绑定。它还可以用于强制编译器通常不会集成的大型过程。 （扩展/优化过程对于确定何时是否进行集成非常有用。）

## 11.2 `syntax-rules` 转换器

Chez Scheme 扩展了 `syntax-rules` 以便允许子句中使用 `syntax-case` 子句中的 fender #TBD。

+ 语法：`(syntax-rules (literal ...) clause ...) `
+ 返回值：转换器 
+ 库：`(chezscheme)`

`literal` 必须是除下划线(`_`)、省略号（`...`）以外的标识符。子句必须是下列形式之一：

```scheme
(pattern template)
(pattern fender template)
```

R6RS只支持第一种形式。

## 11.3. `syntax-case` 转换器

Chez Scheme 提供了几种可用于简化某些句法抽象编码的过程和句法形式。

+ 过程：`(syntax->list syntax-object)`
+ 返回值：一个句法对象表
+ 库：`(chezscheme)`

此过程接受表示表结构形式的句法对象，并返回由句法对象组成的表，其中每个句法对象与输入形式的子形式相对应。

`syntax->list` 可以按如下定义：

```scheme
(define syntax->list
  (lambda (ls)
    (syntax-case ls ()
      [() '()]
      [(x . r) (cons #'x (syntax->list #'r))]))) 

#'(a b c) ; =>  #<syntax (a b c)>
(syntax->list #'(a b c)) ; => (#<syntax a> #<syntax b> #<syntax c>)
```

对于从单个模式变量值或模式变量值序列构造的表，不需要调用 `syntax->list`，因为这样的结构已经是表。例如：

```scheme
(list? (with-syntax ([x #'a] [y #'b] [z #'c]) #'(x y z)))) ; => #t
(list? (with-syntax ([(x ...) #'(a b c)]) #'(x ...))) ; =>  #t
```

+ 过程： `(syntax->vector syntax-object) `
+ 返回值： 一个句法对象表
+ 库：`(chezscheme)`

此过程接受表示向量结构形式的句法对象，并返回由句法对象组成的向量，其中每个句法对象与输入形式的子形式相对应。

> 原句为：This procedure takes a syntax object representing a vector-structured form and returns a **list** of syntax objects, each representing the corresponding subform of the input form.  
> 从例子来看，返回的是一个向量（vector），而不是一个表（list），疑有误。 #TBD

`syntax->vector` 可以按如下定义：

```scheme
(define syntax->vector
  (lambda (v)
    (syntax-case v ()
      [#(x ...) (apply vector (syntax->list #'(x ...)))]))) 

#'#(a b c) ; => #<syntax #(a b c)>
(syntax->vector #'#(a b c)) ; => #(#<syntax a> #<syntax b> #<syntax c>)
```

对于从单个模式变量值或模式变量值序列构造的向量，不需要调用 `syntax->vector`，因为这样的结构已经是向量。例如：

```scheme
(vector? (with-syntax ([x #'a] [y #'b] [z #'c]) #'#(x y z)))) ; => #t
(vector? (with-syntax ([(x ...) #'(a b c)]) #'#(x ...))) ; => #t
```

+ 过程： `(syntax-object->datum obj)`
+ 返回值： 一个剔除了句法信息的对象
+ 库：`(chezscheme)`

`syntax-object->datum` 跟 R6RS 中的 `syntax->datum` 完全相同。

+ 过程： `(datum template)`
+ 返回值：见如下
+ 库：`(chezscheme)`

`(datum template)` 是一种方便的简写语法，表示：

```scheme
(syntax->datum (syntax template))
```

可以像下面这样简单地定义 `datum`：

```scheme
(define-syntax datum
  (syntax-rules ()
    [(_ t) (syntax->datum #'t)])) 

(with-syntax ((a #'(a b c))) (datum a)) ; => (a b c)
```

+ 过程：`(datum->syntax-object template-identifier obj)`
+ 返回值：一个语法对象
+ 库：`(chezscheme)`

`datum->syntax-object` 跟 R6RS 中的 `datum->syntax` 完全相同。

+ 句法：`(with-implicit (id0 id1 ...) body1 body2 ...)`
+ 返回值：见如下
+ 库：`(chezscheme)`

这个句法抽象了用于创建隐式标识符的 `datum->syntax` 的常见用法（参见上文）。句法：

```scheme
(with-implicit (id0 id1 ...)
  body1 body2 ...)
```

等同于：

```scheme
(with-syntax ([id1 (datum->syntax #'id0 'id1)] ...)
  body1 body2 ...)
```

可以像下面这样简单地定义 `with-implicit`：

```scheme
(define-syntax with-implicit
  (syntax-rules ()
    [(_ (tid id ...) b1 b2 ...)
     (with-syntax ([id (datum->syntax #'tid 'id)] ...)
       b1 b2 ...)]))
```

我们用 `with-implicit` 来简化上述的 `loop` 实现（这也是正确的版本）。

```scheme
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(k e ...)
       (with-implicit (k break)
         #'(call-with-current-continuation
             (lambda (break)
               (let f () e ... (f)))))])))
```

+ 句法：`(include path)`
+ 返回值：未定义
+ 库：`(chezscheme)`

`path`必须是一个字符串。`include` 形式被展开为一个 `begin` 表达式，后者包含了在名为 `path` 的文件中找到的形式。例如，如果文件 `f-def.ss` 包含了 `(define f (lambda () x))`，那么表达式：

```scheme
(let ([x "okay"])
  (include "f-def.ss")
  (f))
```

会被求值为 `"okay"`。如果 `include` 形式出现在定义序列中，并且由 `path` 指定的文件中的形式都是定义，则将其视为定义，如上例所示。如果文件包含表达式，则 `include` 形式将被视为表达式。

尽管 Chez Scheme 使用依赖于实现的定义，允许它捕获和维护包含代码的源信息，但是可移植版本的 `include` 可以按如下定义：

```scheme
(define-syntax include
  (lambda (x)
    (define read-file
      (lambda (fn k)
        (let ([p (open-input-file fn)])
          (let f ([x (read p)])
            (if (eof-object? x)
                (begin (close-input-port p) '())
                (cons (datum->syntax k x)
                      (f (read p))))))))
    (syntax-case x ()
      [(k filename)
       (let ([fn (datum filename)])
         (with-syntax ([(exp ...) (read-file fn #'k)])
           #'(begin exp ...)))])))
```

`include` 的定义使用 `datum->syntax` 将从文件读取的对象转换为适当词法上下文中的句法对象，以便这些表达式中的标识符引用和定义在 `include` 形式出现的范围内。

在 Chez Scheme 的 `include` 实现中，参数 `source-directories`（第12.5节）决定搜索未由绝对路径名标识的源文件的目录集。

+ 过程：`(syntax-error obj string ...)`
+ 返回值：不返回
+ 库：`(chezscheme)`

可以使用 `syntax-error` 报告句法错误，该句法错误通过串联 `string ...` 和 `obj` 的打印表示来生成消息。如果未提供字符串参数，则使用字符串 `"invalid syntax"`。 当 `obj` 是句法对象时，在创建打印表示之前，会剥离句法对象包装器（与`syntax->datum` 一样）。如果源文件信息存在于 `syntax-object` 包装器中，则 `syntax-error` 将此信息合并到错误消息中。

如果输入无法匹配其中一个子句，则 `syntax-case` 和 `syntax-rules` 会自动调用 `syntax-error` 。

我们可以使用 `syntax-error` 来精确地报告在（匿名）`let` 以下定义的中检测到的错误的诱因。

```scheme
(define-syntax let
  (lambda (x)
    (define check-ids!
      (lambda (ls)
        (unless (null? ls)
          (unless (identifier? (car ls))
            (syntax-error (car ls) "let cannot bind non-identifier"))
          (check-ids! (cdr ls)))))
    (define check-unique!
      (lambda (ls)
        (unless (null? ls)
          (let ([x (car ls)])
            (when (let mem? ([ls (cdr ls)])
                    (and (not (null? ls))
                         (or (bound-identifier=? x (car ls))
                             (mem? (cdr ls)))))
              (syntax-error x "let cannot bind two occurrences of")))
          (check-unique! (cdr ls)))))
    (syntax-case x ()
      [(_ ((i e) ...) b1 b2 ...)
       (begin
         (check-ids! #'(i ...))
         (check-unique! #'(i ...))
         #'((lambda (i ...) b1 b2 ...) e ...))])))
```

有了这些变动，下面的表达式：

```
(let ([a 3] [a 4]) (+ a a))
```

会产生这样的错误消息：`"let cannot bind two occurrences of a."`。

+ 过程：`(literal-identifier=? identifier1 identifier2)`
+ 返回值：见下
+ 库：`(chezscheme)`

这个过程同 R6RS 中的 `identifier=?` 一致，提供此函数只是为了保证向后兼容。