# 11. 句法扩展和模块

本章描述了 Chez Scheme 对 `syntax-case` 句法抽象机制所做的扩展，这些扩展现已被 R^6RS 报告所标准化。这些扩展包括模块系统（11.5 节）、元定义（11.8 节）、可以作为`syntax-rules` 防护板的按情况展开（11.9 节）、`fluid-let-syntax` 以及 `include` 。


## 11.1 fluid 关键字绑定

通过 R^6RS 报告中的 `define-syntax`、`let-syntax` 以及 `letrec-syntax` 形式定义的关键字绑定，可以使用 `fluid-let-syntax` 临时地重新绑定。

+ 语法：`(fluid-let-syntax ((keyword expr) ...) form1 form2 ...) `
+ 返回：参考解释
+ 库：`(chezscheme)`

每一条 `expr` 必须求值为一个转换器。`fluid-let-syntax` 类似于标准的 `let-syntax`，只不过不会引入关键字 `keyword ...` 的新绑定，`fluid-let-syntax` 会在展开它的程序体的时候，临时修改关键字已有的绑定。也就是说，在展开 `form1 form2 ...` 的时候，每个关键字可见的（或最高层）词法绑定被临时地替换为一个新的关联——即一个关键字与其对应的转换器。这会影响对解析为相同词法（或顶级）绑定的关键字的任何引用，无论引用是在出现在程序体正文还是在展开时引入。相反，`let-syntax` 仅捕获出现在程序体正文中的那些引用。

> #TBD, DeathKing  
> body 要如何翻译？  
> + 显然不是“语句体”，因为 Scheme 中没有语句（statement）这个说法；  
> + 显然也不是“过程体”，因为这里是待展开的形式；  
> + 这里没有使用 `<body>` 这个语法记号，因此也不适宜保留 `<body>` 这样的形式；  
> + 暂时使用“程序体”的说法，如果有更好的说法，稍后会修改。

下面的例子展示了 `fluid-let-syntax` 和 `let-syntax` 的不同：

```scheme
(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([g (syntax-rules ()
                    [(_ x) (f x)])])
    (let-syntax ([f (syntax-rules ()
                      [(_ x) x])])
      (g 1)))) ; => 2 

(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([g (syntax-rules ()
                    [(_ x) (f x)])])
    (fluid-let-syntax ([f (syntax-rules ()
                            [(_ x) x])])
      (g 1)))) ; => 1
```

除了在第二条表达式中，`let-syntax` 形式内部表达式中第一条表达式是 `fluid-let-syntax` 形式，这两条表达式都是相同的。在第一条表达式中，出现在展开 `(g 1)` 过程中的 `f` 引用的是由 `let` 式所绑定的变量 `f`， 而在第二条表达式中的 `f` 引用的是由 `fluid-let-syntax` 所绑定的关键字 `f`。

下面的例子利用 `fluid-let-syntax` 来定义 `define-integrable` 形式，后者类似于用于过程定义的 `define`，但无论在何处直接调用该过程，都导致过程的代码被集成或插入到该位置 #TBD。通过 `define-integrable` 或 `define` 来定义的过程没有语义差异，只不过在最高层， `define-integrable` 形式必须在首次引用所定义的标识符之前出现。词法作用域被保持了，集成调用中的实际参数只在适当的时间求值一次，可集成过程可以用作第一类值，并且递归过程不会导致无限递归扩展。

```scheme
(define-syntax define-integrable
  (syntax-rules (lambda)
    [(_ name (lambda formals form1 form2 ...))
     (begin
       (define xname
         (fluid-let-syntax ([name (identifier-syntax xname)])
           (lambda formals form1 form2 ...)))
       (define-syntax name
         (lambda (x)
           (syntax-case x ()
             [_ (identifier? x) #'xname]
             [(_ arg (... ...))
              #'((fluid-let-syntax ([name (identifier-syntax xname)])
                   (lambda formals form1 form2 ...))
                  arg
                  (... ...))]))))]))
```

`define-integrable` 的语法如下：

```
(define-integrable name lambda-expression)
```

`define-integrable` 形式会被展开为一个由定义构成的序对：关于 `name` 的句法定义以及关于 `xname` 的变量定义 #TBD。跟 `name` 对应的转换器将对于 `name` 的调用展开为对 `lambda`-表达式的直接调用。由于展开的结果仅仅是直接的 `lambda` 应用（等价于 `let` 表达式），因此在求值过程的体之前，实际参数只会刚好被求值一次，正如所要求的那样。所有指向 `name` 的引用都会被指向 `xname` 的引用所替代。`xname` 的定义将其绑定到 `lambda`表达式的值上。这使得该过程可以被用作第一类值。由于 `xname` 是由转换器引入的，因此除了由 `name` 对应的转换器引入的对其的引用，`xname` 的绑定在其它任何地方都是不可见的。

无论 `lambda`-表达式出现在何处，在其内部 `name` 都被重新绑定到一个转换器上，将所有的 `name` 展开为对 `xname` 的引用。以这样的目的使用 `fluid-let-syntax` 可以防止在可集成过程中间接递归的无限展开。 这允许过程可以递归调用而不会导致无限扩展。 `define-integrable` 没有特意维护词法作用域，这是因为词法作用域由展开器自动维护。

Chez Scheme 在适当时自动集成本地定义的过程。但是，它无法集成最高层定义的过程，因为可以随时（通过eval或load）将为最高层变量的赋值代码引入系统。即使本地绑定过程的集成留给编译器，`define-integrable` 可用于强制集成在最高层的定义的过程绑定。它还可以用于强制编译器通常不会集成的大型过程。 （扩展/优化过程对于确定何时是否进行集成非常有用。）

## 11.2 `syntax-rules` 转换器

Chez Scheme 扩展了 `syntax-rules` 以便允许子句中使用 `syntax-case` 子句中的 fender #TBD。

+ 语法：`(syntax-rules (literal ...) clause ...) `
+ 返回值：转换器 
+ 库：`(chezscheme)`

`literal` 必须是除下划线(`_`)、省略号（`...`）以外的标识符。子句必须是下列形式之一：

```scheme
(pattern template)
(pattern fender template)
```

R6RS只支持第一种形式。


