# 4 外部接口(Foreign Interface)
Chez Scheme 提供两种与“外部代码”（即其他语言写的代码）交互的方式。第一种是通过子进程创建和通信，在4.1节进行讨论。第二种是通过静态或者动态加载的方式，在Scheme中调用C编写的过程，或者在C中调用Scheme编写的过程。这些机制在4.2节到4.4节中讨论。

静态加载C目标代码的方法取决于你所运行的机器。详见与Chez Scheme一起发布的安装指示。

## 4.1 子进程通信(Subprocess Communication)

system和process两个过程用来创建子进程。这两个过程都接受一个string类型参数，创建一个子进程来执行string中的shell命令。system过程在返回前等待进程退出，而process过程立即返回，并不等待进程退出。由system创建的子进程的标准输入和输出文件可以被用于与用户console的通信。由process创建的子进程的标准输入和输出文件可以被用于同scheme进程的通信。

*procedure*:(system command)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型

system过程创建一个子进程来执行由command中指定的指令。子进程可通过同一console的输入输出文件（由Scheme procss使用）与用户通信。在创建完子进程后，system在其返回前一直等待子进程退出。

当子进程退出时，system返回子进程的退出码,除非signal导致子进程终止(如在类Unix系统中)。在该情况下，system返回引起进程终止的信号的负数，如SIGHUP为-1。

*procedure*:(open-process-ports command)
*procedure*:(open-process-ports command b-mode)
*procedure*:(open-process-ports command b-mode ?transcoder)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型。如果?transcoder存在且不是#f，且其必须是transcoder，该过程创建了文本端口，每个端口的transcoder为?transcoder。否则，该过程返回二进制端口。b-mode指定该过程返回的每个端口的buffer模式，默认为block。buffer模式在《The Scheme Programming Language, 4th Edition》的7.2节介绍。

open-process-ports创建子进程执行由command指定的指令。与system和process不同处是其在创建子进程后立即返回,即不等待子进程结束。其返回四个值：

1. to-stdin 是输出端口，Scheme能够使用该端口通过子进程的标准输入文件发送输出内容到子进程。
2. from-stdout 是输入端口，Scheme能够使用该端口通过子进程的标准输出文件读取子进程的输出内容。
3. from-stderr 是输入端口，Scheme能够使用该端口通过子进程的标准错误文件读取子进程的输出内容。
4. process-id 是个整数，由操作系统分配，用于识别创建的子进程。

如果子进程退出或者关闭标准输出文件描述符,任何从from-stdout读取内容的过程将会返回end-of-file对象。类似的，如果子进程退出或者关闭标准错误文件描述符，任何从from-stderr读取内容的过程会返回end-of-file对象。(译者注：原文为process进程，而非子进程)

判断input-port-ready?可被用于检测是否有来自子进程的输出内容到达Scheme。

有时需要立即强制输出内容到子进程可在to-stdin上调用flush-output-port，Chez Scheme由于效率原因缓冲输出。

在Unix系统中，process-id是执行command的shell的进程描述符。如果command用于调用可执行文件而非shell命令，需要在command之前加上"exec"，这样shell会直接加载和执行可执行文件，而不会fork一个新进程--尾递归的shell等效。这会减少一个创建的子进程的数量，从而使得process-id反应执行文件的进程描述符，一旦shell完成转移控制。

*procedure*:(process command)
*return*:见解释
*libraries*:(chezscheme)

command 必须是string类型。

process与open-process-ports类似，但不那么一般化。它不返回能够读取子进程标准错误输出的端口，而且它总是创建文本端口。它返回三个值的list，而不是像open-process-ports那样四个独立的值。返回的list依次包含：from-stdout, to-stdin, process-id。分别对应open-process-ports返回值得第二，第一，第四个返回值。

## 4.2 导入Scheme (Calling out of Scheme)

Chez Scheme的foreign-procedure接口允许Scheme程序调用由C或者由遵循C调用规则的语言编写的过程。在外部过程能够被Scheme调用之前需要完成两个步骤。第一，外部过程必须被编译和加载，动态或者静态的加载形式，如在4.6节所述。然后，外部过程的入口必须在Scheme中建立，如本节所述。一旦外部过程的入口建立，就能够像普通Scheme过程那样被调用。

由于外部过程的操作独立于Scheme的内存管理和异常处理系统，在使用它们的时候需要多加小心。尽管，foreign-procedure接口提供类型检查（在小于三级优化下）和类型转换，程序员必须确保Scheme与外部过程之间的共享数据被安全地指定了合适的参数和结果类型。

外部过程的Scheme可调用封装（Scheme-callable wrappers）能够通过ftype-ref和function ftypes创建（见4.5节）。

*syntax*: (foreign-procedure conv ... entry-exp (param-type ...) res-type) 
*returns*: a procedure 
*libraries*: (chezscheme)

entry-exp必须是代表有效外部过程入口的string类型，或代表外部过程地址的integer类型。param-types和res-type必须是symbols或如下所述的结构化表。当foreign-procedure表达式被求值，一个能调用以entry-exp指定的外部过程的Scheme过程被创建。外部过程的调用结果通过转换后被指定为res-type类型。可以对同一个外部入口创建多个Scheme过程。

每个conv用来指定调用规则。conv可以是#f，代表目标机器上的默认调用规则（所以#f没有效果）。在Windows下，另外三个目前支持的调用规则是__stdcall, __cdecl，和__com (只支持32位)。因为__cdecl是默认的，指定__cdecl与指定#f或者不指定是一样的。最后，conv也可以是__collect_safe，用来指定在外部过程运行时，并发允许垃圾回收。

使用__stdcall能够使用大多数Windows API过程。对于Windows API变参数过程，C语言库过程，和大多数其他过程，可以使用__cdecl。使用__com可调用COM接口方法；COM使用__stdcall规则，但是额外增加了必须的间接操作来获取COM实例的正确方法。COM实例的地址必须以第一个参数传递，必须被声明为iptr。只有__com接口，entry-exp必须被指定为COM vtable（COM虚表）中的字节偏移。例如，

`(foreign-procedure __com 12 (iptr double-float) integer-32)`

创建一个在COM实例的vtable中偏移12字节的COM方法的接口，COM实例在第一个参数中传递，第二个参数是double float，返回值类型是integer。

使用__collect_safe声明允许在外部函数调用时，并发允许垃圾回收。__collect_safe声明允许并发回收。通过在外部过程调用时抑制当前线程（见fork-thread），当外部函数返回时线程再次激活。__collect_safe声明是有用的，例如，当调用包含I/O阻塞的调用时，允许其他Scheme线程正常运行。避免传递可回收的内存到__collect_safe的外部过程，或者使用lock-object来锁定内存；（参考Sdeactivate_thread）。__collect_safe声明对于非线程版本的系统是没有效果的。

例如，以默认规则调用C sleep函数会阻塞其他Scheme线程执行垃圾回收，但是加入__collect_safe声明后可以避免该问题：

```
(define c-sleep
  (foreign-procedure __collect_safe "sleep" (unsigned) unsigned))
(c-sleep 10) ; 睡眠10秒钟而不阻塞其他线程
```

如果以__collect_safe方式调用的外部过程能够调用过程，那么被调用的过程也必须是__collect_safe方式，这样被调用的过程才能重新激活线程。

对外部过程的参数进行完整的类型检查和转换。在使用scheme-object, string, wstring, u8*, u16*, u32*, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be这些类型时需要特别小心，因为这些分配出来的Scheme对象允许在Scheme内存管理系统控制不能控制的地方被使用。只要这些对象或者数据结构不在Scheme代码运行时保存在外部变量中，且只要他们不是被传递到__collect_safe过程中，就不会发生问题，因为垃圾回收只有在Scheme代码运行时或者当并发垃圾回收被开启的情况下才执行。其他参数类型被等价转换成外部表示方式，他们能够无期限地被保存在外部变量和数据结构中。

对于string, wstring, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be参数类型，一个参数会被转换成一个新的对象后再传给外部过程。因为新的对象在调用前不能被锁定，它不会被__collect_safe外部过程正确处理，所以这些类型不允许作为__collect_safe外部过程的参数类型。基于类似的理由，这些类型也不允许作为__collect_safe外部调用的返回值类型。

以下是合法的参数类型：

integer-8: 从-2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 2<sup>7</sup>  到 2<sup>8</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是signed char）。

unsigned-8: 从 -2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 -2<sup>7</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xff。参数作为一个合适大小的整数类型传递给C（通常是unsigned char）。

integer-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。2<sup>15</sup>  到 2<sup>16</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffff 是 -1。参数作为一个合适大小的整数类型传递给C (通常是short)。

unsigned-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。-2<sup>15</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffff。参数作为一个合适大小的整数类型传递给C (通常是 unsigned short)。

integer-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。2<sup>31</sup>  到 2<sup>32</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffffffff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是int）。

unsigned-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。-2<sup>31</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffffffff. 参数作为一个合适大小的整数类型传递给C（通常是unsigned int）。

integer-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。2<sup>63</sup>  到 2<sup>64</sup> - 1 范围内的整数被认为是负数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是long long，或者在许多64位机器上long）。

unsigned-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。-2<sup>63</sup> 到 -1范围内的整数被认为是整数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是unsigned long long，或者在许多64位机器上unsigned long）(译者注：原文为long）。

double-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为双精度double类型传递给C。

single-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为单精度float类型传递给C。由于Chez Scheme以double-float类型表示flonums，参数首先会转换到single-float格式。

short: 该类型是以上合适固定大小类型的别名，取决于C中short的大小。

unsigned-short: 该类型是以上合适固定大小类型的别名，取决于C中unsigned short的大小。

int: 该类型是以上合适固定大小类型的别名，取决于C中int的大小。

unsigned: 该类型是以上合适固定大小类型的别名，取决于C中unsigned的大小。

unsigned-int: 该类型是unsinged类型的别名。固定大小类型，取决于C中unsigned的大小。

long: 该类型是以上合适固定大小类型的别名，取决于C中long的大小。

unsigned-long: 该类型是以上合适固定大小类型的别名，取决于C中unsigned long的大小。

long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中long long的大小。

unsigned-long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中unsigned long long的大小。

ptrdiff_t: 该类型是以上合适固定大小类型的别名，取决于在宿主机器stddef.h头文件中的定义。

size_t: 该类型是以上合适固定大小无符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

ssize_t: 该类型是以上合适固定大小有符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

iptr: 该类型是以上合适固定大小类型的别名，取决于C中指针类型的大小。

uptr: 该类型是以上合适固定大小（无符号）类型的别名，取决于C中指针类型的大小。

void*: 该类型是uptr的别名。

fixnum: 该类型等效于iptr，除了在fixnum范围内的数值有效。传输fixnums比传输iptr值稍微快一点，但是fixnum的范围更小，所以有效iptr值没有fixnum的表示。

boolean: 任何Scheme对象可以被当做boolean传递。#f会被转换为0。所有其他对象被转换为1。参数以int类型传递给C。

char: 只有Scheme字符和在0~255范围的Unicode标量值是有效char参数。字符通过char->integer被转换为Unicode标量值，以unsigned char类型传递给C。

wchar_t: 只有Scheme的字符是有效wchar_t参数。在Windows和其他任何wchar_t只有16bit值而不是所有Unicode标量值的系统中，只有16bit Unicode标量值的字符有效。在wchar_t时32bit值得系统中，任何Scheme字符是有效的。字符通过char->integer被转换成Unicode标量值，以wchar_t类型传递给C。

wchar: 该类型是wchar_t的别名。

double: 该类型是double-float的别名。

float: 该类型是single-float的别名。

scheme-object: 该参数直接传递给外部过程；没有转换，没有类型检查。这种形式的参数传递应该被谨慎使用。Scheme objects不该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用的间隙重定位它们。

ptr: 该类型是scheme-object的别名。

u8*: 该参数必须是Scheme bytevector或者#f类型。对于#f，null pointer (0)被传递给外部过程。对于bytevector，指向bytevector数据的第一个字节的指针被传递给外部过程。如果被传递数据的C程序要求输入以'\0'结尾，那么 null (0)字节必须被显示包含在bytevector中。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。

u16*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么两个null (0)字节必须被显示包含在bytevector中，以16bit边界对齐。

u32*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么四个null (0)字节必须被显示包含在bytevector中，以32bit边界对齐。

utf-8: 该参数必须是Scheme string类型或者#f。对于#f，null pointer (0)被传递给外部过程。string被转换成bytevector，好像通过string-utf8一样，增加了null字节，第一个bytevector第一个字节的地址被传递给C。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。__collect_safe指定的外部过程不允许utf-8参数类型。

utf-16le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness little方式，后面追加了两个null字节而不是一个。

utf-16be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness big方式，后面追加了两个null字节而不是一个。

utf-32le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness little方式，后面追加了四个null字节而不是一个。

utf-32be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness big方式，后面追加了四个null字节而不是一个。

string: 该类型是utf-8的别名。

wstring: 该类型是utf-16le，utf-16be，utf-32le，或utf-32be的别名，取决于C中wchar_t的大小和目标机器的endianness。例如，在Intel处理器的Windows系统中wstring等效于utf-16le。

(* ftype): 该类型允许外部类型ftype的指针被传递。参数必须是类型ftype的ftype指针，真实的参数是ftype指针所封装的地址。见4.5节外部类型描述。

(& ftype): 该类型允许外部类型ftype以值得形式传递，但是在Scheme方面是以外部类型数据的指针方式。也就是说， (& ftype) 参数在Scheme方面与 (* ftype) 参数一样，但是 (& ftype) 参数是以外部指针地址中的内容而非地址传递给外部过程。例如，如果ftype是struct类型，那么(& ftype)传递struct参数而不是struct-pointer参数。ftype不能引用array类型。

The result types are similar to the parameter types with the addition of a void type. In general, the type conversions are the inverse of the parameter type conversions. No error checking is performed on return, since the system cannot determine whether a foreign result is actually of the indicated type. Particular caution should be exercised with the result types scheme-object, double-float, double, single-float, float, and the types that result in the construction of bytevectors or strings, since invalid return values may lead to invalid memory references as well as incorrect computations. Following are the valid result types:

void: The result of the foreign procedure call is ignored and an unspecified Scheme object is returned. void should be used when foreign procedures are called for effect only.

integer-8: The result is interpreted as a signed 8-bit integer and is converted to a Scheme exact integer.

unsigned-8: The result is interpreted as an unsigned 8-bit integer and is converted to a Scheme nonnegative exact integer.

integer-16: The result is interpreted as a signed 16-bit integer and is converted to a Scheme exact integer.

unsigned-16: The result is interpreted as an unsigned 16-bit integer and is converted to a Scheme nonnegative exact integer.

integer-32: The result is interpreted as a signed 32-bit integer and is converted to a Scheme exact integer.

unsigned-32: The result is interpreted as an unsigned 32-bit integer and is converted to a Scheme nonnegative exact integer.

integer-64: The result is interpreted as a signed 64-bit integer and is converted to a Scheme exact integer.

unsigned-64: The result is interpreted as an unsigned 64-bit integer and is converted to a Scheme nonnegative exact integer.

double-float: The result is interpreted as a double float and is translated into a Chez Scheme flonum.

single-float: The result is interpreted as a single float and is translated into a Chez Scheme flonum. Since Chez Scheme represents flonums in double-float format, the result is first converted into double-float format.

short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C short.

unsigned-short: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned short.

int: This type is an alias for the appropriate fixed-size type above, depending on the size of a C int.

unsigned: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned.

unsigned-int: This type is an alias unsigned. fixed-size type above, depending on the size of a C unsigned.

long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C long.

unsigned-long: This type is an alias for the appropriate fixed-size type above, depending on the size of a C unsigned long.

long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type long long.

unsigned-long-long: This type is an alias for the appropriate fixed-size type above, depending on the size of the nonstandard C type unsigned long long.

ptrdiff_t: This type is an alias for the appropriate fixed-size type above, depending on its definition in the host machine's stddef.h include file.

size_t: This type is an alias for the appropriate unsigned fixed-size type above, depending on its definition in the host machine's stddef.h include file.

ssize_t: This type is an alias for the appropriate signed fixed-size type above, depending on its definition in the host machine's stddef.h include file.

iptr: This type is an alias for the appropriate fixed-size type above, depending on the size of a C pointer.

uptr: This type is an alias for the appropriate (unsigned) fixed-size type above, depending on the size of a C pointer.

void*: This type is an alias for uptr.

boolean: This type converts a C int return value into a Scheme boolean. 0 is converted to #f; all other values are converted to #t.

char: This type converts a C unsigned char return value into a Scheme character, as if via integer->char.

wchar_t: This type converts a C wchar_t return value into a Scheme character, as if via integer->char. The wchar_t value must be a valid Unicode scalar value.

wchar: This type is an alias for wchar_t.

double: This type is an alias for double-float.

float: This type is an alias for single-float.

scheme-object: The result is assumed to be a valid Scheme object, and no conversion is performed. This type is inherently dangerous, since an invalid Scheme object can corrupt the memory management system with unpredictable (but always unpleasant) results. Since Scheme objects are actually typed pointers, even integers cannot safely be returned as type scheme-object unless they were created by the Scheme system.

ptr: This type is an alias for scheme-object.

u8*: The result is interpreted as a pointer to a null-terminated sequence of 8-bit unsigned integers (bytes). If the result is a null pointer, #f is returned. Otherwise, the sequence of bytes is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme.

u16*: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of 16-bit integers is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme. The null terminator must be a properly aligned 16-bit word, i.e., two bytes of zero aligned on a 16-bit boundary.

u32*: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of 16-bit integers is stored in a freshly allocated bytevector of the appropriate length, and the bytevector is returned to Scheme. The null terminator must be a properly aligned 32-bit word, i.e., four bytes of zero aligned on a 32-bit boundary.

utf-8: The result is interpreted as a pointer to a null-terminated sequence of 8-bit unsigned character values. If the result is a null pointer, #f is returned. Otherwise, the sequence of bytes is converted into a Scheme string, as if via utf8->string, and the string is returned to Scheme.

utf-16le: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf16->string with endianness little, and the string is returned to Scheme. A byte-order mark in the sequence of integers as treated as an ordinary character value and does not affect the byte ordering.

utf-16be: The result is interpreted as a pointer to a null-terminated sequence of 16-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf16->string with endianness big, and the string is returned to Scheme. A byte-order mark in the sequence of integers as treated as an ordinary character value and does not affect the byte ordering.

utf-32le: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf32->string with endianness little, and the string is returned to Scheme. A byte-order mark in the sequence of integers as treated as an ordinary character value and does not affect the byte ordering.

utf-32be: The result is interpreted as a pointer to a null-terminated sequence of 32-bit unsigned integers. If the result is a null pointer, #f is returned. Otherwise, the sequence of integers is converted into a Scheme string, as if via utf32->string with endianness big, and the string is returned to Scheme. A byte-order mark in the sequence of integers as treated as an ordinary character value and does not affect the byte ordering.

string: This type is an alias for utf-8.

wstring: This type is an alias for utf-16le, utf-16be, utf-32le, or utf-32be as appropriate depending on the size of a C wchar_t and the endianness of the target machine. For example, wstring is equivalent to utf-16le under Windows running on Intel hardware.

(* ftype): The result is interpreted as the address of a foreign object whose structure is described by ftype, and a freshly allocated ftype pointer encapsulating the address is returned. See Section 4.5 for a description of foreign types.

(& ftype): The result is interpreted as a foreign object whose structure is described by ftype, where the foreign procedure returns a ftype result, but the caller must provide an extra (* ftype) argument before all other arguments to receive the result. An unspecified Scheme object is returned when the foreign procedure is called, since the result is instead written into storage referenced by the extra argument. The ftype cannot refer to an array type.

Consider a C identity procedure:

`int id(x) int x; { return x; }`

After a file containing this procedure has been compiled and loaded (see Section 4.6) it can be accessed as follows:

```
(foreign-procedure "id"
  (int) int) <graphic> #<procedure>
((foreign-procedure "id"
   (int) int)
 1) <graphic> 1
(define int-id
  (foreign-procedure "id"
    (int) int))
(int-id 1) <graphic> 1
```

The "id" entry can also be interpreted as accepting and returning a boolean:

```
(define bool-id
  (foreign-procedure "id"
    (boolean) boolean))
(bool-id #f) <graphic> #f
(bool-id #t) <graphic> #t
(bool-id 1) <graphic> #t
```

As the last example reveals, bool-id is actually a conversion procedure. When a Scheme object is passed as type boolean it is converted to 0 or 1, and when it is returned it is converted to #f or #t. As a result objects are converted to normalized boolean values. The "id" entry can be used to create other conversion procedures by varying the type specifications:

```
(define int->bool
  (foreign-procedure "id"
    (int) boolean))
(int->bool 0) <graphic> #f
(int->bool 5) <graphic> #t
(map (foreign-procedure "id"
       (boolean) int)
     '(#t #f)) <graphic> (1 0)
(define void
  (foreign-procedure "id"
    (int) void))
(void 10) <graphic> unspecified
```

There are, of course, simpler and more efficient ways of accomplishing these conversions directly in Scheme.

A foreign entry is resolved when a foreign-procedure expression is evaluated, rather than either when the code is loaded or each time the procedure is invoked. Thus, the following definition is always valid since the foreign-procedure expression is not immediately evaluated:

```
(define doit
  (lambda ()
    ((foreign-procedure "doit" () void))))
```

doit should not be invoked, however, before an entry for "doit" has been provided. Similarly, an entry for "doit" must exist before the following code is evaluated:

```
(define doit
  (foreign-procedure "doit" () void))
```

Although the second definition is more constraining on the load order of foreign files, it is more efficient since the entry resolution need be done only once.

It is often useful to define a template to be used in the creation of several foreign procedures with similar argument types and return values. For example, the following code creates two foreign procedures from a single foreign procedure expression, by abstracting out the foreign procedure name:

```
(define double->double
  (lambda (proc-name)
    (foreign-procedure proc-name
      (double)
      double))) 

(define log10 (double->double "log10"))
(define gamma (double->double "gamma"))
```

Both "log10" and "gamma" must be available as foreign entries (see Section 4.6) before the corresponding definitions. The use of foreign procedure templates can simplify the coding process and reduce the amount of code generated when a large number of foreign procedures are involved, e.g., when an entire library of foreign procedures is imported into Scheme.

## 4.3 从Scheme导出

## 4.4 延续和外部引用

## 4.5 外部数据

## 4.6 访问外部过程

可以通过以下几种方式获得外部过程：

可以使用加载动态链接库过程 load-shared-object 加载外部过程。
一个新的Chez Scheme映像可以用加载外部代码构建的方式链接。Sforeign_symbol Sregister_symbol 参见4.8
其他条目可以动态加载或以其他方式由外部代码获得。通常也使用Sforeign_symbol Sregister_symbol进行注册。
入口地址，比如函数指针，可以被传递给Scheme，并用作外部过程表达式中入口语句的值。即使没有按照名称注册，也可以使用外部入口点。
过程：(foreign-entry? entry-name）
返回：如果entry-name存在，返回#t，否则#f
库：(chezscheme)
entry-name 必须是 string，可用于确定是否存在外部程序的过程。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
foreign-entry? "strlen"）#  => t 
    ((foreign-procedure "strlen" 
    (string) size_t)
 "hey!"）  => 4
 ```
过程：(foreign-entry entry-name)
返回：以integer返回entry-name名称的address
库：(chezscheme)
入口名称必须是一个命名现有外来入口点的字符串。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。

```
(let ([addr (foreign-entry "strlen")])
    (and (integer? addr) (exact? addr))) => #t 

(define-ftype strlen-type (function (string) size_t))
(define strlen
    (ftype-ref strlen-type ()
    (make-ftype-pointer strlen-type "strlen")))
(strlen "hey!") => 4
```
过程：(foreign-address-name address)
返回：address对应的entry-name。若不存在，返回#f
库：(chezscheme)
以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
(foreign-address-name (foreign-entry "strlen")) => "strlen"
```
过程：(load-shared-object path)
返回：unspecified 
库：(chezscheme)
path必须是一个字符串。load-shared-object加载由path指定的动态链接库。动态链接库可能是系统库或从普通C程序创建的文件。动态链接库中的所有外部符号以及与shared-object链接的其他动态链接库中可用的外部符号都可用作外部条目。

在Chez Scheme运行的大多数平台上都支持这个过程。

如果path不以"."或者"/"开始，shared-object将在系统默认的环境变量中进行搜索。

在大多数Unix系统上，load-shared-object基于系统例程dlopen。在Windows下，load-shared-object基于LoadLibrary。有关这些例程的文档，请参阅C编译器和加载器，以获取有关查找和构建动态链接库的精确规则。

load-shared-object可以用来访问内置的C库函数，比如getenv。动态链接库的名称因系统而异，在Linux系统上：

`（load-shared-object "libc.so.6"）`

在Solaris，OpenSolaris，FreeBSD，NetBSD和OpenBSD系统上：

`（load-shared-object "libc.so"）`

在MacOS X系统上：

`(load-shared-object "libc.dylib")`
在Windows上：

`(load-shared-object "crtdll.dll")`
一旦C库被加载，getenv应该可以作为一个外部入口：

`(foreign-entry? "getenv") => #t`
可以这样定义和调用等效的Scheme过程：
```
(define getenv
    (foreign-procedure "getenv"
        (string)
        string))
(getenv "HOME") => "/home/elmer/fudd"
(getenv "home") => #f
```
load-shared-object也可以用来访问用户创建的库，

假设C文件"env.c"包含

int even(n) int n; { return n == 0 || odd(n - 1); }
C文件"odd.c"包含

int odd(n) int n; { return n != 0 && even(n - 1); }
这些文件必须被编译并链接到动态链接库才能被加载。其过程取决于系统：

在Linux，FreeBSD，OpenBSD和OpenSolaris上：

(system "cc -fPIC -shared -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在MacOS X（Intel或PowerPC）系统上：

(system "cc -dynamiclib -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在32位Sparc Solaris上：

(system "cc -KPIC -G -o evenodd.so even.c odd.c")
在64位Sparc Solaris上：

(system "cc -xarch=v9 -KPIC -G -o evenodd.so even.c odd.c")
在Windows上，我们构建一个DLL（动态链接库）文件。为了使编译器生成适当的入口点，我们改变even.c来读取

```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif 
```
EXPORT int even(n) int n; { return n == 0 || odd(n - 1); }
和odd.c读取
```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif 
```
EXPORT int odd(n) int n; { return n != 0 && even(n - 1); }
然后，我们可以按如下所示构建DLL，并为其提供扩展名“.so”而不是“.dll”，以便与其他系统保持一致。
```
(system "cl -c -DWIN32 even.c")
(system "cl -c -DWIN32 odd.c")
(system "link -dll -out:evenodd.so even.obj odd.obj")
```
生成的“.so”文件可以加载到Scheme中，even和odd可以作为外部过程使用：
```
(load-shared-object "./evenodd.so")
(let ([odd (foreign-procedure "odd"
             (integer-32) boolean)]
      [even (foreign-procedure "even"
              (integer-32) boolean)])
  (list (even 100) (odd 100))) => (#t #f)
```
文件名以“./evenodd.so”定义，而不是简单的“evenodd.so”，因为有些系统在不包含当前目录的标准系统目录集中查找共享库。

过程：(remove-foreign-entry entry-name) 
返回：unspecified 
库： (chezscheme)
remove-foreign-entry将访问由entry-name指定的入口。如果目标不存在，就会引发异常。可在外部接口建立后用remove-foreign-entry而不影响之前由foreign-procedure建立的接口访问。

使用remove-foreign-entry可删除使用Sforeign_symbol和Sregister_symbol注册的条目，但不能删除由调用load-shared-object而创建的条目。

###4.7 使用其他的编程语言

尽管Chez Scheme外部过程接口主要面向C中定义的过程或C库中可用的过程，但也可以调用其他语言中遵循C调用约定的过程。一个难点的来源可能是名字的解释。基于Unix的C编译器通常会在外部名称前加一个下划线，外部接口将尝试以与主机C编译器一致的方式解释条目名称。

偶尔，如汇编代码文件，这个条目的名称可能不以被期望的方式解释。通过在条目名称前添加一个“=”字符来防止。

例如，加载包含过程“foo”的程序集文件后，可能会有
```
（foreign-entry？“foo”）#  => f 
（foreign-entry？“= foo”）#  => t
```

###4.8 C库过程

###4.9 示例：套接字操作

C code. 

```
/* csocket.c */ 

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h> 

/* c_write attempts to write the entire buffer, pushing through
   interrupts, socket delays, and partial-buffer writes */
int c_write(int fd, char *buf, ssize_t start, ssize_t n) {
    ssize_t i, m; 

    buf += start;
    m = n;
    while (m > 0) {
        if ((i = write(fd, buf, m)) < 0) {
            if (errno != EAGAIN && errno != EINTR)
                return i;
        } else {
            m -= i;
            buf += i;
        }
    }
    return n;
} 

/* c_read pushes through interrupts and socket delays */
int c_read(int fd, char *buf, size_t start, size_t n) {
    int i; 

    buf += start;
    for (;;) {
        i = read(fd, buf, n);
        if (i >= 0) return i;
        if (errno != EAGAIN && errno != EINTR) return -1;
    }
} 

/* bytes_ready(fd) returns true if there are bytes available
   to be read from the socket identified by fd */
int bytes_ready(int fd) {
    int n; 

    (void) ioctl(fd, FIONREAD, &n);
    return n;
} 

/* socket support */ 

/* do_socket() creates a new AF_UNIX socket */
int do_socket(void) { 

    return socket(AF_UNIX, SOCK_STREAM, 0);
} 

/* do_bind(s, name) binds name to the socket s */
int do_bind(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return bind(s, (struct sockaddr*)(&sun), length);
} 

/* do_accept accepts a connection on socket s */
int do_accept(int s) {
    struct sockaddr_un sun;
    socklen_t length; 

    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return accept(s, (struct sockaddr*)(&sun), &length);
} 

/* do_connect initiates a socket connection */
int do_connect(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return connect(s, (struct sockaddr*)(&sun), length);
} 

/* get_error returns the operating system's error status */
char* get_error(void) {
    extern int errno;
    return strerror(errno);
}
```
Scheme code.  

```
;;; socket.ss 

;;; Requires csocket.so, built from csocket.c.
(load-shared-object "./csocket.so") 

;;; Requires from C library:
;;;   close, dup, execl, fork, kill, listen, tmpnam, unlink
(case (machine-type)
  [(i3le ti3le a6le ta6le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx) (load-shared-object "libc.dylib")]
  [else (load-shared-object "libc.so")]) 

;;; basic C-library stuff 

(define close
  (foreign-procedure "close" (int)
    int)) 

(define dup
  (foreign-procedure "dup" (int)
    int)) 

(define execl4
  (let ((execl-help
         (foreign-procedure "execl"
           (string string string string void*)
           int)))
    (lambda (s1 s2 s3 s4)
      (execl-help s1 s2 s3 s4 0)))) 

(define fork
  (foreign-procedure "fork" ()
    int)) 

(define kill
  (foreign-procedure "kill" (int int)
    int)) 

(define listen
  (foreign-procedure "listen" (int int)
    int)) 

(define tmpnam
  (foreign-procedure "tmpnam" (void*)
    string)) 

(define unlink
  (foreign-procedure "unlink" (string)
    int)) 

;;; routines defined in csocket.c 

(define accept
  (foreign-procedure "do_accept" (int)
    int)) 

(define bytes-ready?
  (foreign-procedure "bytes_ready" (int)
    boolean)) 

(define bind
  (foreign-procedure "do_bind" (int string)
    int)) 

(define c-error
  (foreign-procedure "get_error" ()
    string)) 

(define c-read
  (foreign-procedure "c_read" (int u8* size_t size_t)
    ssize_t)) 

(define c-write
  (foreign-procedure "c_write" (int u8* size_t ssize_t)
    ssize_t)) 

(define connect
  (foreign-procedure "do_connect" (int string)
    int)) 

(define socket
  (foreign-procedure "do_socket" ()
    int)) 

;;; higher-level routines 

(define dodup
 ; (dodup old new) closes old and dups new, then checks to
 ; make sure that resulting fd is the same as old
  (lambda (old new)
    (check 'close (close old))
    (unless (= (dup new) old)
      (error 'dodup
        "couldn't set up child process io for fd ~s" old)))) 

(define dofork
 ; (dofork child parent) forks a child process and invokes child
 ; without arguments and parent with the child's pid
  (lambda (child parent)
    (let ([pid (fork)])
      (cond
        [(= pid 0) (child)]
        [(> pid 0) (parent pid)]
        [else (error 'fork (c-error))])))) 

(define setup-server-socket
 ; create a socket, bind it to name, and listen for connections
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (unlink name)
      (check 'bind (bind sock name))
      (check 'listen (listen sock 1))
      sock))) 

(define setup-client-socket
 ; create a socket and attempt to connect to server
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (check 'connect (connect sock name))
      sock))) 

(define accept-socket
 ; accept a connection
  (lambda (sock)
    (check 'accept (accept sock)))) 

(define check
 ; signal an error if status x is negative, using c-error to
 ; obtain the operating-system's error message
  (lambda (who x)
    (if (< x 0)
        (error who (c-error))
        x))) 

(define terminate-process
 ; kill the process identified by pid
  (lambda (pid)
    (define sigterm 15)
    (kill pid sigterm)
    (void)))
```

Sample session. 
```
> (define client-pid)
> (define client-socket)
> (let* ([server-socket-name (tmpnam 0)]
         [server-socket (setup-server-socket server-socket-name)])
   ; fork a child, use it to exec a client Scheme process, and set
   ; up server-side client-pid and client-socket variables.
    (dofork   ; child
      (lambda () 
       ; the child establishes the socket input/output fds as
       ; stdin and stdout, then starts a new Scheme session
        (check 'close (close server-socket))
        (let ([sock (setup-client-socket server-socket-name)])
          (dodup 0 sock)
          (dodup 1 sock))
        (check 'execl (execl4 "/bin/sh" "/bin/sh" "-c" "exec scheme -q"))
        (errorf 'client "returned!"))
      (lambda (pid) ; parent
       ; the parent waits for a connection from the client
        (set! client-pid pid)
        (set! client-socket (accept-socket server-socket))
        (check 'close (close server-socket)))))
> (define put ; procedure to send data to client
    (lambda (x)
      (let ([s (format "~s~%" x)])
        (c-write client-socket s (string-length s)))
      (void)))
> (define get ; procedure to read data from client
    (let ([buff (make-string 1024)])
      (lambda ()
        (let ([n (c-read client-socket buff (string-length buff))])
          (printf "client:~%~a~%server:~%" (substring buff 0 n))))))
> (get)
server:
> (put '(let ([x 3]) x))
> (get)
client:
3
server:
> (terminate-process client-pid)
> (exit)
```