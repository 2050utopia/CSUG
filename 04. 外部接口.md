# 4 外部接口(Foreign Interface)
Chez Scheme 提供两种与“外部代码”（即其他语言写的代码）交互的方式。第一种是通过子进程创建和通信，在4.1节进行讨论。第二种是通过静态或者动态加载的方式，在Scheme中调用C编写的过程，或者在C中调用Scheme编写的过程。这些机制在4.2节到4.4节中讨论。

静态加载C目标代码的方法取决于你所运行的机器。详见与Chez Scheme一起发布的安装指示。

## 4.1 子进程通信(Subprocess Communication)

system和process两个过程用来创建子进程。这两个过程都接受一个string类型参数，创建一个子进程来执行string中的shell命令。system过程在返回前等待进程退出，而process过程立即返回，并不等待进程退出。由system创建的子进程的标准输入和输出文件可以被用于与用户console的通信。由process创建的子进程的标准输入和输出文件可以被用于同scheme进程的通信。

*procedure*:(system command)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型

system过程创建一个子进程来执行由command中指定的指令。子进程可通过同一console的输入输出文件（由Scheme procss使用）与用户通信。在创建完子进程后，system在其返回前一直等待子进程退出。

当子进程退出时，system返回子进程的退出码,除非signal导致子进程终止(如在类Unix系统中)。在该情况下，system返回引起进程终止的信号的负数，如SIGHUP为-1。

*procedure*:(open-process-ports command)
*procedure*:(open-process-ports command b-mode)
*procedure*:(open-process-ports command b-mode ?transcoder)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型。如果?transcoder存在且不是#f，且其必须是transcoder，该过程创建了文本端口，每个端口的transcoder为?transcoder。否则，该过程返回二进制端口。b-mode指定该过程返回的每个端口的buffer模式，默认为block。buffer模式在《The Scheme Programming Language, 4th Edition》的7.2节介绍。

open-process-ports创建子进程执行由command指定的指令。与system和process不同处是其在创建子进程后立即返回,即不等待子进程结束。其返回四个值：

1. to-stdin 是输出端口，Scheme能够使用该端口通过子进程的标准输入文件发送输出内容到子进程。
2. from-stdout 是输入端口，Scheme能够使用该端口通过子进程的标准输出文件读取子进程的输出内容。
3. from-stderr 是输入端口，Scheme能够使用该端口通过子进程的标准错误文件读取子进程的输出内容。
4. process-id 是个整数，由操作系统分配，用于识别创建的子进程。

如果子进程退出或者关闭标准输出文件描述符,任何从from-stdout读取内容的过程将会返回end-of-file对象。类似的，如果子进程退出或者关闭标准错误文件描述符，任何从from-stderr读取内容的过程会返回end-of-file对象。(译者注：原文为process进程，而非子进程)

判断input-port-ready?可被用于检测是否有来自子进程的输出内容到达Scheme。

有时需要立即强制输出内容到子进程可在to-stdin上调用flush-output-port，Chez Scheme由于效率原因缓冲输出。

在Unix系统中，process-id是执行command的shell的进程描述符。如果command用于调用可执行文件而非shell命令，需要在command之前加上"exec"，这样shell会直接加载和执行可执行文件，而不会fork一个新进程--尾递归的shell等效。这会减少一个创建的子进程的数量，从而使得process-id反应执行文件的进程描述符，一旦shell完成转移控制。

*procedure*:(process command)
*return*:见解释
*libraries*:(chezscheme)

command 必须是string类型。

process与open-process-ports类似，但不那么一般化。它不返回能够读取子进程标准错误输出的端口，而且它总是创建文本端口。它返回三个值的list，而不是像open-process-ports那样四个独立的值。返回的list依次包含：from-stdout, to-stdin, process-id。分别对应open-process-ports返回值得第二，第一，第四个返回值。

## 4.2 导入Scheme (Calling out of Scheme)

Chez Scheme的foreign-procedure接口允许Scheme程序调用由C或者由遵循C调用规则的语言编写的过程。在外部过程能够被Scheme调用之前需要完成两个步骤。第一，外部过程必须被编译和加载，动态或者静态的加载形式，如在4.6节所述。然后，外部过程的入口必须在Scheme中建立，如本节所述。一旦外部过程的入口建立，就能够像普通Scheme过程那样被调用。

由于外部过程的操作独立于Scheme的内存管理和异常处理系统，在使用它们的时候需要多加小心。尽管，foreign-procedure接口提供类型检查（在小于三级优化下）和类型转换，程序员必须确保Scheme与外部过程之间的共享数据被安全地指定了合适的参数和结果类型。

外部过程的Scheme可调用封装（Scheme-callable wrappers）能够通过ftype-ref和function ftypes创建（见4.5节）。

*syntax*: (foreign-procedure conv ... entry-exp (param-type ...) res-type) 
*returns*: a procedure 
*libraries*: (chezscheme)

entry-exp必须是代表有效外部过程入口的string类型，或代表外部过程地址的integer类型。param-types和res-type必须是symbols或如下所述的结构化表。当foreign-procedure表达式被求值，一个能调用以entry-exp指定的外部过程的Scheme过程被创建。外部过程的调用结果通过转换后被指定为res-type类型。可以对同一个外部入口创建多个Scheme过程。

每个conv用来指定调用规则。conv可以是#f，代表目标机器上的默认调用规则（所以#f没有效果）。在Windows下，另外三个目前支持的调用规则是__stdcall, __cdecl，和__com (只支持32位)。因为__cdecl是默认的，指定__cdecl与指定#f或者不指定是一样的。最后，conv也可以是__collect_safe，用来指定在外部过程运行时，并发允许垃圾回收。

使用__stdcall能够使用大多数Windows API过程。对于Windows API变参数过程，C语言库过程，和大多数其他过程，可以使用__cdecl。使用__com可调用COM接口方法；COM使用__stdcall规则，但是额外增加了必须的间接操作来获取COM实例的正确方法。COM实例的地址必须以第一个参数传递，必须被声明为iptr。只有__com接口，entry-exp必须被指定为COM vtable（COM虚表）中的字节偏移。例如，

`(foreign-procedure __com 12 (iptr double-float) integer-32)`

创建一个在COM实例的vtable中偏移12字节的COM方法的接口，COM实例在第一个参数中传递，第二个参数是double float，返回值类型是integer。

使用__collect_safe声明允许在外部函数调用时，并发允许垃圾回收。__collect_safe声明允许并发回收。通过在外部过程调用时抑制当前线程（见fork-thread），当外部函数返回时线程再次激活。__collect_safe声明是有用的，例如，当调用包含I/O阻塞的调用时，允许其他Scheme线程正常运行。避免传递可回收的内存到__collect_safe的外部过程，或者使用lock-object来锁定内存；（参考Sdeactivate_thread）。__collect_safe声明对于非线程版本的系统是没有效果的。

例如，以默认规则调用C sleep函数会阻塞其他Scheme线程执行垃圾回收，但是加入__collect_safe声明后可以避免该问题：

```
(define c-sleep
  (foreign-procedure __collect_safe "sleep" (unsigned) unsigned))
(c-sleep 10) ; 睡眠10秒钟而不阻塞其他线程
```

如果以__collect_safe方式调用的外部过程能够调用过程，那么被调用的过程也必须是__collect_safe方式，这样被调用的过程才能重新激活线程。

对外部过程的参数进行完整的类型检查和转换。在使用scheme-object, string, wstring, u8*, u16*, u32*, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be这些类型时需要特别小心，因为这些分配出来的Scheme对象允许在Scheme内存管理系统控制不能控制的地方被使用。只要这些对象或者数据结构不在Scheme代码运行时保存在外部变量中，且只要他们不是被传递到__collect_safe过程中，就不会发生问题，因为垃圾回收只有在Scheme代码运行时或者当并发垃圾回收被开启的情况下才执行。其他参数类型被等价转换成外部表示方式，他们能够无期限地被保存在外部变量和数据结构中。

对于string, wstring, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be参数类型，一个参数会被转换成一个新的对象后再传给外部过程。因为新的对象在调用前不能被锁定，它不会被__collect_safe外部过程正确处理，所以这些类型不允许作为__collect_safe外部过程的参数类型。基于类似的理由，这些类型也不允许作为__collect_safe外部调用的返回值类型。

以下是合法的参数类型：

integer-8: 从-2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 2<sup>7</sup>  到 2<sup>8</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是signed char）。

unsigned-8: 从 -2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 -2<sup>7</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xff。参数作为一个合适大小的整数类型传递给C（通常是unsigned char）。

integer-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。2<sup>15</sup>  到 2<sup>16</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffff 是 -1。参数作为一个合适大小的整数类型传递给C (通常是short)。

unsigned-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。-2<sup>15</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffff。参数作为一个合适大小的整数类型传递给C (通常是 unsigned short)。

integer-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。2<sup>31</sup>  到 2<sup>32</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffffffff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是int）。

unsigned-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。-2<sup>31</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffffffff. 参数作为一个合适大小的整数类型传递给C（通常是unsigned int）。

integer-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。2<sup>63</sup>  到 2<sup>64</sup> - 1 范围内的整数被认为是负数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是long long，或者在许多64位机器上long）。

unsigned-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。-2<sup>63</sup> 到 -1范围内的整数被认为是整数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是unsigned long long，或者在许多64位机器上unsigned long）(译者注：原文为long）。

double-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为双精度double类型传递给C。

single-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为单精度float类型传递给C。由于Chez Scheme以double-float类型表示flonums，参数首先会转换到single-float格式。

short: 该类型是以上合适固定大小类型的别名，取决于C中short的大小。

unsigned-short: 该类型是以上合适固定大小类型的别名，取决于C中unsigned short的大小。

int: 该类型是以上合适固定大小类型的别名，取决于C中int的大小。

unsigned: 该类型是以上合适固定大小类型的别名，取决于C中unsigned的大小。

unsigned-int: 该类型是unsinged类型的别名。固定大小类型，取决于C中unsigned的大小。

long: 该类型是以上合适固定大小类型的别名，取决于C中long的大小。

unsigned-long: 该类型是以上合适固定大小类型的别名，取决于C中unsigned long的大小。

long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中long long的大小。

unsigned-long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中unsigned long long的大小。

ptrdiff_t: 该类型是以上合适固定大小类型的别名，取决于在宿主机器stddef.h头文件中的定义。

size_t: 该类型是以上合适固定大小无符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

ssize_t: 该类型是以上合适固定大小有符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

iptr: 该类型是以上合适固定大小类型的别名，取决于C中指针类型的大小。

uptr: 该类型是以上合适固定大小（无符号）类型的别名，取决于C中指针类型的大小。

void*: 该类型是uptr的别名。

fixnum: 该类型等效于iptr，除了在fixnum范围内的数值有效。传输fixnums比传输iptr值稍微快一点，但是fixnum的范围更小，所以有效iptr值没有fixnum的表示。

boolean: 任何Scheme对象可以被当做boolean传递。#f会被转换为0。所有其他对象被转换为1。参数以int类型传递给C。

char: 只有Scheme字符和在0~255范围的Unicode标量值是有效char参数。字符通过char->integer被转换为Unicode标量值，以unsigned char类型传递给C。

wchar_t: 只有Scheme的字符是有效wchar_t参数。在Windows和其他任何wchar_t只有16bit值而不是所有Unicode标量值的系统中，只有16bit Unicode标量值的字符有效。在wchar_t时32bit值得系统中，任何Scheme字符是有效的。字符通过char->integer被转换成Unicode标量值，以wchar_t类型传递给C。

wchar: 该类型是wchar_t的别名。

double: 该类型是double-float的别名。

float: 该类型是single-float的别名。

scheme-object: 该参数直接传递给外部过程；没有转换，没有类型检查。这种形式的参数传递应该被谨慎使用。Scheme objects不该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用的间隙重定位它们。

ptr: 该类型是scheme-object的别名。

u8*: 该参数必须是Scheme bytevector或者#f类型。对于#f，null pointer (0)被传递给外部过程。对于bytevector，指向bytevector数据的第一个字节的指针被传递给外部过程。如果被传递数据的C程序要求输入以'\0'结尾，那么 null (0)字节必须被显示包含在bytevector中。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。

u16*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么两个null (0)字节必须被显示包含在bytevector中，以16bit边界对齐。

u32*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么四个null (0)字节必须被显示包含在bytevector中，以32bit边界对齐。

utf-8: 该参数必须是Scheme string类型或者#f。对于#f，null pointer (0)被传递给外部过程。string被转换成bytevector，好像通过string-utf8一样，增加了null字节，第一个bytevector第一个字节的地址被传递给C。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。__collect_safe指定的外部过程不允许utf-8参数类型。

utf-16le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness little方式，后面追加了两个null字节而不是一个。

utf-16be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness big方式，后面追加了两个null字节而不是一个。

utf-32le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness little方式，后面追加了四个null字节而不是一个。

utf-32be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness big方式，后面追加了四个null字节而不是一个。

string: 该类型是utf-8的别名。

wstring: 该类型是utf-16le，utf-16be，utf-32le，或utf-32be的别名，取决于C中wchar_t的大小和目标机器的endianness。例如，在Intel处理器的Windows系统中wstring等效于utf-16le。

(* ftype): 该类型允许外部类型ftype的指针被传递。参数必须是类型ftype的ftype指针，真实的参数是ftype指针所封装的地址。见4.5节外部类型描述。

(& ftype): 该类型允许外部类型ftype以值得形式传递，但是在Scheme方面是以外部类型数据的指针方式。也就是说， (& ftype) 参数在Scheme方面与 (* ftype) 参数一样，但是 (& ftype) 参数是以外部指针地址中的内容而非地址传递给外部过程。例如，如果ftype是struct类型，那么(& ftype)传递struct参数而不是struct-pointer参数。ftype不能引用array类型。

返回值类型和参数类型情况类似，增加了一个void类型。一般来说，类型转换是参数类型转换的逆过程。在返回时灭有错误检查，应为系统不能决定一个外部结果是否真的是其所指示的类型。在使用过程中需要特别注意scheme-object, double-float, double, single-float, float和会创建bytevectors或strings的类型，因为无效的返回值可能会导致不正确的内存引用和不正确的计算。以下是有效的返回值类型：

void: 外部函数过程的返回值被忽略，未指定的Scheme对象被返回。void 用于只是产生效果的外部过程的调用。

integer-8: 结果被解译为signed 8-bit integer，并转换为Scheme exact integer。

unsigned-8: 结果被解译为unsigned 8-bit integer，并转换为Scheme非负exact integer。

integer-16: 结果被解译为signed 16-bit integer，并转换为Scheme exact integer。

unsigned-16: 结果被解译为unsigned 16-bit integer，并转换为Scheme非负exact integer。

integer-32: 结果被解译为signed 32-bit integer，并转换为Scheme exact integer。

unsigned-32: 结果被解译为unsigned 32-bit integer，并转换为Scheme非负exact integer。

integer-64: 结果被解译为signed 64-bit integer，并转换为Scheme exact integer。

unsigned-64: 结果被解译为unsigned 64-bit integer，并转换为Scheme非负exact integer。

double-float: 结果被解译为双精度浮点型double float，并被转换为Chez Scheme flonum。

single-float: 结果被解译为双精度浮点型single float，并被转换为Chez Scheme flonum。因为Chez Scheme用double-float格式表示flonums，结果首先被转换成double-float格式。

short: 该类型是以上合适固定大小类型的别名，取决于C short的大小。

unsigned-short: 该类型是以上合适固定大小类型的别名,取决于C unsigned short大小。

int: 该类型是以上合适固定大小类型的别名，取决于C int的大小。

unsigned: 该类型是以上合适固定大小类型的别名，取决于C unsigned的大小。

unsigned-int: 该类型是以上合适固定大小类型unsigned的别名，取决于C unsigned的大小。

long: 该类型是以上合适固定大小类型的别名，取决于C long的大小。

unsigned-long: 该类型是以上合适固定大小类型的别名，取决于C unsigned long的大小。

long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C long long的大小。

unsigned-long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C unsigned long long的大小。

ptrdiff_t: 该类型是以上合适固定大小类型的别名，取决于宿主机器stddef.h头文件中的定义。

size_t: 该类型是以上合适固定大小unsigned类型的别名，取决于宿主机器stddef.h头文件中的定义。

ssize_t: 该类型是以上合适固定大小signed类型的别名，取决于宿主机器stddef.h头文件中的定义。

iptr: 该类型是以上合适固定大小类型的别名，取决于C中指针的大小。

uptr: 该类型是以上合适固定大小(unsigned)类型的别名，取决于C中指针的大小。

void*: 该类型是uptr的别名。

boolean: 该类型把C int返回值转换为Scheme boolean。0为#f，其他值为#t。

char: 该类型把C unsigned char类型转换为Scheme character，就像通过integer->char。

wchar_t: 该类型把C wchar_t返回值转化为Scheme character，就像通过integer->char。wchar_t值必须是一个有效地Unicode标量值。

wchar: 该类型是wchar_t的别名。

double: 该类型是double-float的别名。

float: 该类型是single-float的别名。

scheme-object: 结果被假设为一个有效的Scheme object，不进行转换。该类型具有危险性，因为无效的Scheme object会导致内存管理系统不确定的错误结果（通常是不不好的）。由于Scheme object实际上是typed指针，甚至integers也不能安全地被返回为scheme-object，除非他们是由Scheme系统创建的。

ptr: 该类型是scheme-object的别名。

u8*: 结果被解译为一个'\0'结尾的8-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。

u16*: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，16-bit integers序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。null 结尾符为16 bit对齐，即两个字节的16-bit对齐边界。

u32*: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，32-bit integers序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。null 结尾符为32-bit对齐，即四个字节的32-bit对齐边界。(译者注：原文为the sequence of 16-bit integers)

utf-8: 结果被解译为一个'\0'结尾的8-bit unsigned character序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string类型，就像通过utf8->string，string返回给Scheme。

utf-16le: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf16->string，以endianness little方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-16be: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf16->string，以endianness big方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-32le: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf32->string，以endianness little方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-32be: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf32->string，以endianness big方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

string: 该类型是utf-8的别名。

wstring: 该类型是utf-16le, utf-16be, utf-32le, utf-32be中合适类型的别名，取决于C中wchar_t的大小和目标机器的endianness。例如，wstring在Intel硬件的Windows系统上等效于utf-16le。

(* ftype): 结果被解译为外部对象的地址，其由ftype描述，新分配的封装该地址的ftype指针被返回。见4.5节对外部类型的描述。

(& ftype): 结果被解译为外部对象，其由ftype描述，外部函数返回一个ftype结果，但是，调用者必须在其他调用参数前提供一个额外的(* ftype)参数来接收结果。外部过程调用后一个未指定的Scheme对象被返回，因为结果被写入由额外参数引用的储存空间中。ftype不能引用array类型。

我们看下C identity过程：

`int id(x) int x; { return x; }`

当包含该过程的文件被编译加载（见4.6），它能够由以下方式访问：

```
(foreign-procedure "id"
  (int) int)
=> #<procedure>
((foreign-procedure "id"
   (int) int)
 1)
=> 1
(define int-id
  (foreign-procedure "id"
    (int) int))
(int-id 1)
=> 1
```

“id”入口能够被解译为接收和返回boolean类型：

```
(define bool-id
  (foreign-procedure "id"
    (boolean) boolean))
(bool-id #f)
=> #f
(bool-id #t)
=> #t
(bool-id 1)
=> #t
```

如上例所揭示的，bool-id实际上是转换过程。当Scheme对象以类型boolean传递时，其被转换为0或1，当其返回时被转换为#f或#t。结果被转换成规范化的boolean值。通过变换类型指定，“id”入口能够被用来创建其他转换过程。

```
(define int->bool
  (foreign-procedure "id"
    (int) boolean))
(int->bool 0)
=> #f
(int->bool 5)
=> #t
(map (foreign-procedure "id"
       (boolean) int)
     '(#t #f))
=> (1 0)

(define void
  (foreign-procedure "id"
    (int) void))
(void 10)
=> unspecified
```

当然在Scheme中有更加简单、高效的直接完成转换的方式。

当foreign-procedure表达式被求值时外部入口被解析，而不是代码被加载或者每次调用时。因此，以下定义总是有效地，因为foreign-procedure表达式不是立即被求值：

```
(define doit
  (lambda ()
    ((foreign-procedure "doit" () void))))
```

在“doit”的入口未被提供前，doit不应该被调用。类似地，“doit”的入口必须在以下代码求值前存在。

```
(define doit
  (foreign-procedure "doit" () void))
```

尽管第二种定义更加限制外部文件的加载顺序，但是更加有效率，因为入口解析只需要做一次。

定义一个模板用于创建几个具有类似参数类型和返回值的外部过程，这通常很有用。例如，以下代码从一个外部过程表达式创建两个外部过程，通过抽象出外部过程名字：

```
(define double->double
  (lambda (proc-name)
    (foreign-procedure proc-name
      (double)
      double)))

(define log10 (double->double "log10"))
(define gamma (double->double "gamma"))
```

在对应的定义之前，“log10”和“gamma”都必须存在外部入口（见4.6节）。使用外部过程模板能够简化编码过程，减少需要生成大量外部过程所使用的代码量，例如，当整个库的外部过程被导入到Scheme中。

## 4.3 从Scheme导出

## 4.4 延续和外部引用

## 4.5 外部数据

## 4.6 访问外部过程

可以通过以下几种方式获得外部过程：

可以使用加载动态链接库过程 load-shared-object 加载外部过程。
一个新的Chez Scheme映像可以用加载外部代码构建的方式链接。Sforeign_symbol Sregister_symbol 参见4.8
其他条目可以动态加载或以其他方式由外部代码获得。通常也使用Sforeign_symbol Sregister_symbol进行注册。
入口地址，比如函数指针，可以被传递给Scheme，并用作外部过程表达式中入口语句的值。即使没有按照名称注册，也可以使用外部入口点。
过程：(foreign-entry? entry-name）
返回：如果entry-name存在，返回#t，否则#f
库：(chezscheme)
entry-name 必须是 string，可用于确定是否存在外部程序的过程。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
foreign-entry? "strlen"）#  => t 
    ((foreign-procedure "strlen" 
    (string) size_t)
 "hey!"）  => 4
 ```
过程：(foreign-entry entry-name)
返回：以integer返回entry-name名称的address
库：(chezscheme)
入口名称必须是一个命名现有外来入口点的字符串。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。

```
(let ([addr (foreign-entry "strlen")])
    (and (integer? addr) (exact? addr))) => #t 

(define-ftype strlen-type (function (string) size_t))
(define strlen
    (ftype-ref strlen-type ()
    (make-ftype-pointer strlen-type "strlen")))
(strlen "hey!") => 4
```
过程：(foreign-address-name address)
返回：address对应的entry-name。若不存在，返回#f
库：(chezscheme)
以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
(foreign-address-name (foreign-entry "strlen")) => "strlen"
```
过程：(load-shared-object path)
返回：unspecified 
库：(chezscheme)
path必须是一个字符串。load-shared-object加载由path指定的动态链接库。动态链接库可能是系统库或从普通C程序创建的文件。动态链接库中的所有外部符号以及与shared-object链接的其他动态链接库中可用的外部符号都可用作外部条目。

在Chez Scheme运行的大多数平台上都支持这个过程。

如果path不以"."或者"/"开始，shared-object将在系统默认的环境变量中进行搜索。

在大多数Unix系统上，load-shared-object基于系统例程dlopen。在Windows下，load-shared-object基于LoadLibrary。有关这些例程的文档，请参阅C编译器和加载器，以获取有关查找和构建动态链接库的精确规则。

load-shared-object可以用来访问内置的C库函数，比如getenv。动态链接库的名称因系统而异，在Linux系统上：

`（load-shared-object "libc.so.6"）`

在Solaris，OpenSolaris，FreeBSD，NetBSD和OpenBSD系统上：

`（load-shared-object "libc.so"）`

在MacOS X系统上：

`(load-shared-object "libc.dylib")`
在Windows上：

`(load-shared-object "crtdll.dll")`
一旦C库被加载，getenv应该可以作为一个外部入口：

`(foreign-entry? "getenv") => #t`
可以这样定义和调用等效的Scheme过程：
```
(define getenv
    (foreign-procedure "getenv"
        (string)
        string))
(getenv "HOME") => "/home/elmer/fudd"
(getenv "home") => #f
```
load-shared-object也可以用来访问用户创建的库，

假设C文件"env.c"包含

int even(n) int n; { return n == 0 || odd(n - 1); }
C文件"odd.c"包含

int odd(n) int n; { return n != 0 && even(n - 1); }
这些文件必须被编译并链接到动态链接库才能被加载。其过程取决于系统：

在Linux，FreeBSD，OpenBSD和OpenSolaris上：

(system "cc -fPIC -shared -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在MacOS X（Intel或PowerPC）系统上：

(system "cc -dynamiclib -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在32位Sparc Solaris上：

(system "cc -KPIC -G -o evenodd.so even.c odd.c")
在64位Sparc Solaris上：

(system "cc -xarch=v9 -KPIC -G -o evenodd.so even.c odd.c")
在Windows上，我们构建一个DLL（动态链接库）文件。为了使编译器生成适当的入口点，我们改变even.c来读取

```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif 
```
EXPORT int even(n) int n; { return n == 0 || odd(n - 1); }
和odd.c读取
```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif 
```
EXPORT int odd(n) int n; { return n != 0 && even(n - 1); }
然后，我们可以按如下所示构建DLL，并为其提供扩展名“.so”而不是“.dll”，以便与其他系统保持一致。
```
(system "cl -c -DWIN32 even.c")
(system "cl -c -DWIN32 odd.c")
(system "link -dll -out:evenodd.so even.obj odd.obj")
```
生成的“.so”文件可以加载到Scheme中，even和odd可以作为外部过程使用：
```
(load-shared-object "./evenodd.so")
(let ([odd (foreign-procedure "odd"
             (integer-32) boolean)]
      [even (foreign-procedure "even"
              (integer-32) boolean)])
  (list (even 100) (odd 100))) => (#t #f)
```
文件名以“./evenodd.so”定义，而不是简单的“evenodd.so”，因为有些系统在不包含当前目录的标准系统目录集中查找共享库。

过程：(remove-foreign-entry entry-name) 
返回：unspecified 
库： (chezscheme)
remove-foreign-entry将访问由entry-name指定的入口。如果目标不存在，就会引发异常。可在外部接口建立后用remove-foreign-entry而不影响之前由foreign-procedure建立的接口访问。

使用remove-foreign-entry可删除使用Sforeign_symbol和Sregister_symbol注册的条目，但不能删除由调用load-shared-object而创建的条目。

###4.7 使用其他的编程语言

尽管Chez Scheme外部过程接口主要面向C中定义的过程或C库中可用的过程，但也可以调用其他语言中遵循C调用约定的过程。一个难点的来源可能是名字的解释。基于Unix的C编译器通常会在外部名称前加一个下划线，外部接口将尝试以与主机C编译器一致的方式解释条目名称。

偶尔，如汇编代码文件，这个条目的名称可能不以被期望的方式解释。通过在条目名称前添加一个“=”字符来防止。

例如，加载包含过程“foo”的程序集文件后，可能会有
```
（foreign-entry？“foo”）#  => f 
（foreign-entry？“= foo”）#  => t
```

###4.8 C库过程

###4.9 示例：套接字操作

C code. 

```
/* csocket.c */ 

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h> 

/* c_write attempts to write the entire buffer, pushing through
   interrupts, socket delays, and partial-buffer writes */
int c_write(int fd, char *buf, ssize_t start, ssize_t n) {
    ssize_t i, m; 

    buf += start;
    m = n;
    while (m > 0) {
        if ((i = write(fd, buf, m)) < 0) {
            if (errno != EAGAIN && errno != EINTR)
                return i;
        } else {
            m -= i;
            buf += i;
        }
    }
    return n;
} 

/* c_read pushes through interrupts and socket delays */
int c_read(int fd, char *buf, size_t start, size_t n) {
    int i; 

    buf += start;
    for (;;) {
        i = read(fd, buf, n);
        if (i >= 0) return i;
        if (errno != EAGAIN && errno != EINTR) return -1;
    }
} 

/* bytes_ready(fd) returns true if there are bytes available
   to be read from the socket identified by fd */
int bytes_ready(int fd) {
    int n; 

    (void) ioctl(fd, FIONREAD, &n);
    return n;
} 

/* socket support */ 

/* do_socket() creates a new AF_UNIX socket */
int do_socket(void) { 

    return socket(AF_UNIX, SOCK_STREAM, 0);
} 

/* do_bind(s, name) binds name to the socket s */
int do_bind(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return bind(s, (struct sockaddr*)(&sun), length);
} 

/* do_accept accepts a connection on socket s */
int do_accept(int s) {
    struct sockaddr_un sun;
    socklen_t length; 

    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return accept(s, (struct sockaddr*)(&sun), &length);
} 

/* do_connect initiates a socket connection */
int do_connect(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return connect(s, (struct sockaddr*)(&sun), length);
} 

/* get_error returns the operating system's error status */
char* get_error(void) {
    extern int errno;
    return strerror(errno);
}
```
Scheme code.  

```
;;; socket.ss 

;;; Requires csocket.so, built from csocket.c.
(load-shared-object "./csocket.so") 

;;; Requires from C library:
;;;   close, dup, execl, fork, kill, listen, tmpnam, unlink
(case (machine-type)
  [(i3le ti3le a6le ta6le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx) (load-shared-object "libc.dylib")]
  [else (load-shared-object "libc.so")]) 

;;; basic C-library stuff 

(define close
  (foreign-procedure "close" (int)
    int)) 

(define dup
  (foreign-procedure "dup" (int)
    int)) 

(define execl4
  (let ((execl-help
         (foreign-procedure "execl"
           (string string string string void*)
           int)))
    (lambda (s1 s2 s3 s4)
      (execl-help s1 s2 s3 s4 0)))) 

(define fork
  (foreign-procedure "fork" ()
    int)) 

(define kill
  (foreign-procedure "kill" (int int)
    int)) 

(define listen
  (foreign-procedure "listen" (int int)
    int)) 

(define tmpnam
  (foreign-procedure "tmpnam" (void*)
    string)) 

(define unlink
  (foreign-procedure "unlink" (string)
    int)) 

;;; routines defined in csocket.c 

(define accept
  (foreign-procedure "do_accept" (int)
    int)) 

(define bytes-ready?
  (foreign-procedure "bytes_ready" (int)
    boolean)) 

(define bind
  (foreign-procedure "do_bind" (int string)
    int)) 

(define c-error
  (foreign-procedure "get_error" ()
    string)) 

(define c-read
  (foreign-procedure "c_read" (int u8* size_t size_t)
    ssize_t)) 

(define c-write
  (foreign-procedure "c_write" (int u8* size_t ssize_t)
    ssize_t)) 

(define connect
  (foreign-procedure "do_connect" (int string)
    int)) 

(define socket
  (foreign-procedure "do_socket" ()
    int)) 

;;; higher-level routines 

(define dodup
 ; (dodup old new) closes old and dups new, then checks to
 ; make sure that resulting fd is the same as old
  (lambda (old new)
    (check 'close (close old))
    (unless (= (dup new) old)
      (error 'dodup
        "couldn't set up child process io for fd ~s" old)))) 

(define dofork
 ; (dofork child parent) forks a child process and invokes child
 ; without arguments and parent with the child's pid
  (lambda (child parent)
    (let ([pid (fork)])
      (cond
        [(= pid 0) (child)]
        [(> pid 0) (parent pid)]
        [else (error 'fork (c-error))])))) 

(define setup-server-socket
 ; create a socket, bind it to name, and listen for connections
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (unlink name)
      (check 'bind (bind sock name))
      (check 'listen (listen sock 1))
      sock))) 

(define setup-client-socket
 ; create a socket and attempt to connect to server
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (check 'connect (connect sock name))
      sock))) 

(define accept-socket
 ; accept a connection
  (lambda (sock)
    (check 'accept (accept sock)))) 

(define check
 ; signal an error if status x is negative, using c-error to
 ; obtain the operating-system's error message
  (lambda (who x)
    (if (< x 0)
        (error who (c-error))
        x))) 

(define terminate-process
 ; kill the process identified by pid
  (lambda (pid)
    (define sigterm 15)
    (kill pid sigterm)
    (void)))
```

Sample session. 
```
> (define client-pid)
> (define client-socket)
> (let* ([server-socket-name (tmpnam 0)]
         [server-socket (setup-server-socket server-socket-name)])
   ; fork a child, use it to exec a client Scheme process, and set
   ; up server-side client-pid and client-socket variables.
    (dofork   ; child
      (lambda () 
       ; the child establishes the socket input/output fds as
       ; stdin and stdout, then starts a new Scheme session
        (check 'close (close server-socket))
        (let ([sock (setup-client-socket server-socket-name)])
          (dodup 0 sock)
          (dodup 1 sock))
        (check 'execl (execl4 "/bin/sh" "/bin/sh" "-c" "exec scheme -q"))
        (errorf 'client "returned!"))
      (lambda (pid) ; parent
       ; the parent waits for a connection from the client
        (set! client-pid pid)
        (set! client-socket (accept-socket server-socket))
        (check 'close (close server-socket)))))
> (define put ; procedure to send data to client
    (lambda (x)
      (let ([s (format "~s~%" x)])
        (c-write client-socket s (string-length s)))
      (void)))
> (define get ; procedure to read data from client
    (let ([buff (make-string 1024)])
      (lambda ()
        (let ([n (c-read client-socket buff (string-length buff))])
          (printf "client:~%~a~%server:~%" (substring buff 0 n))))))
> (get)
server:
> (put '(let ([x 3]) x))
> (get)
client:
3
server:
> (terminate-process client-pid)
> (exit)
```
