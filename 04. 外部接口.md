# 4 外部接口(Foreign Interface)
Chez Scheme 提供两种与“外部代码”（即其他语言写的代码）交互的方式。第一种是通过子进程创建和通信，在4.1节进行讨论。第二种是通过静态或者动态加载的方式，在Scheme中调用C编写的过程，或者在C中调用Scheme编写的过程。这些机制在4.2节到4.4节中讨论。

静态加载C目标代码的方法取决于你所运行的机器。详见与Chez Scheme一起发布的安装指示。

## 4.1 子进程通信(Subprocess Communication)

system和process两个过程用来创建子进程。这两个过程都接受一个string类型参数，创建一个子进程来执行string中的shell命令。system过程在返回前等待进程退出，而process过程立即返回，并不等待进程退出。由system创建的子进程的标准输入和输出文件可以被用于与用户console的通信。由process创建的子进程的标准输入和输出文件可以被用于同scheme进程的通信。

*procedure*:(system command)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型

system过程创建一个子进程来执行由command中指定的指令。子进程可通过同一console的输入输出文件（由Scheme procss使用）与用户通信。在创建完子进程后，system在其返回前一直等待子进程退出。

当子进程退出时，system返回子进程的退出码,除非signal导致子进程终止(如在类Unix系统中)。在该情况下，system返回引起进程终止的信号的负数，如SIGHUP为-1。

*procedure*:(open-process-ports command)
*procedure*:(open-process-ports command b-mode)
*procedure*:(open-process-ports command b-mode ?transcoder)
*return*:见下文
*libraries*:(chezscheme)

command 必须是string类型。如果?transcoder存在且不是#f，且其必须是transcoder，该过程创建了文本端口，每个端口的transcoder为?transcoder。否则，该过程返回二进制端口。b-mode指定该过程返回的每个端口的buffer模式，默认为block。buffer模式在《The Scheme Programming Language, 4th Edition》的7.2节介绍。

open-process-ports创建子进程执行由command指定的指令。与system和process不同处是其在创建子进程后立即返回,即不等待子进程结束。其返回四个值：

1. to-stdin 是输出端口，Scheme能够使用该端口通过子进程的标准输入文件发送输出内容到子进程。
2. from-stdout 是输入端口，Scheme能够使用该端口通过子进程的标准输出文件读取子进程的输出内容。
3. from-stderr 是输入端口，Scheme能够使用该端口通过子进程的标准错误文件读取子进程的输出内容。
4. process-id 是个整数，由操作系统分配，用于识别创建的子进程。

如果子进程退出或者关闭标准输出文件描述符,任何从from-stdout读取内容的过程将会返回end-of-file对象。类似的，如果子进程退出或者关闭标准错误文件描述符，任何从from-stderr读取内容的过程会返回end-of-file对象。(译者注：原文为process进程，而非子进程)

判断input-port-ready?可被用于检测是否有来自子进程的输出内容到达Scheme。

有时需要立即强制输出内容到子进程可在to-stdin上调用flush-output-port，Chez Scheme由于效率原因缓冲输出。

在Unix系统中，process-id是执行command的shell的进程描述符。如果command用于调用可执行文件而非shell命令，需要在command之前加上"exec"，这样shell会直接加载和执行可执行文件，而不会fork一个新进程--尾递归的shell等效。这会减少一个创建的子进程的数量，从而使得process-id反应执行文件的进程描述符，一旦shell完成转移控制。

*procedure*:(process command)
*return*:见解释
*libraries*:(chezscheme)

command 必须是string类型。

process与open-process-ports类似，但不那么一般化。它不返回能够读取子进程标准错误输出的端口，而且它总是创建文本端口。它返回三个值的list，而不是像open-process-ports那样四个独立的值。返回的list依次包含：from-stdout, to-stdin, process-id。分别对应open-process-ports返回值得第二，第一，第四个返回值。

## 4.2 导入Scheme (Calling out of Scheme)

Chez Scheme的foreign-procedure接口允许Scheme程序调用由C或者由遵循C调用规则的语言编写的过程。在外部过程能够被Scheme调用之前需要完成两个步骤。第一，外部过程必须被编译和加载，动态或者静态的加载形式，如在4.6节所述。然后，外部过程的入口必须在Scheme中建立，如本节所述。一旦外部过程的入口建立，就能够像普通Scheme过程那样被调用。

由于外部过程的操作独立于Scheme的内存管理和异常处理系统，在使用它们的时候需要多加小心。尽管，foreign-procedure接口提供类型检查（在小于三级优化下）和类型转换，程序员必须确保Scheme与外部过程之间的共享数据被安全地指定了合适的参数和结果类型。

外部过程的Scheme可调用封装（Scheme-callable wrappers）能够通过ftype-ref和function ftypes创建（见4.5节）。

*syntax*: (foreign-procedure conv ... entry-exp (param-type ...) res-type) 
*returns*: a procedure 
*libraries*: (chezscheme)

entry-exp必须是代表有效外部过程入口的string类型，或代表外部过程地址的integer类型。param-types和res-type必须是symbols或如下所述的结构化形式。当foreign-procedure表达式被求值，一个能调用以entry-exp指定的外部过程的Scheme过程被创建。外部过程的调用结果通过转换后被指定为res-type类型。可以对同一个外部入口创建多个Scheme过程。

每个conv用来指定调用规则。conv可以是#f，代表目标机器上的默认调用规则（所以#f没有效果）。在Windows下，另外三个目前支持的调用规则是__stdcall, __cdecl，和__com (只支持32位)。因为__cdecl是默认的，指定__cdecl与指定#f或者不指定是一样的。最后，conv也可以是__collect_safe，用来指定在外部过程运行时，并发允许垃圾回收。

使用__stdcall能够使用大多数Windows API过程。对于Windows API变参数过程，C语言库过程，和大多数其他过程，可以使用__cdecl。使用__com可调用COM接口方法；COM使用__stdcall规则，但是额外增加了必须的间接操作来获取COM实例的正确方法。COM实例的地址必须以第一个参数传递，必须被声明为iptr。只有__com接口，entry-exp必须被指定为COM vtable（COM虚表）中的字节偏移。例如，

`(foreign-procedure __com 12 (iptr double-float) integer-32)`

创建一个在COM实例的vtable中偏移12字节的COM方法的接口，COM实例在第一个参数中传递，第二个参数是double float，返回值类型是integer。

使用__collect_safe声明允许在外部函数调用时，并发允许垃圾回收。__collect_safe声明允许并发回收。通过在外部过程调用时抑制当前线程（见fork-thread），当外部函数返回时线程再次激活。__collect_safe声明是有用的，例如，当调用包含I/O阻塞的调用时，允许其他Scheme线程正常运行。避免传递可回收的内存到__collect_safe的外部过程，或者使用lock-object来锁定内存；（参考Sdeactivate_thread）。__collect_safe声明对于非线程版本的系统是没有效果的。

例如，以默认规则调用C sleep函数会阻塞其他Scheme线程执行垃圾回收，但是加入__collect_safe声明后可以避免该问题：

```
(define c-sleep
  (foreign-procedure __collect_safe "sleep" (unsigned) unsigned))
(c-sleep 10) ; 睡眠10秒钟而不阻塞其他线程
```

如果以__collect_safe方式调用的外部过程能够调用过程，那么被调用的过程也必须是__collect_safe方式，这样被调用的过程才能重新激活线程。

对外部过程的参数进行完整的类型检查和转换。在使用scheme-object, string, wstring, u8*, u16*, u32*, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be这些类型时需要特别小心，因为这些分配出来的Scheme对象允许在Scheme内存管理系统控制不能控制的地方被使用。只要这些对象或者数据结构不在Scheme代码运行时保存在外部变量中，且只要他们不是被传递到__collect_safe过程中，就不会发生问题，因为垃圾回收只有在Scheme代码运行时或者当并发垃圾回收被开启的情况下才执行。其他参数类型被等价转换成外部表示方式，他们能够无期限地被保存在外部变量和数据结构中。

对于string, wstring, utf-8, utf-16le, utf-16be, utf-32le, and utf-32be参数类型，一个参数会被转换成一个新的对象后再传给外部过程。因为新的对象在调用前不能被锁定，它不会被__collect_safe外部过程正确处理，所以这些类型不允许作为__collect_safe外部过程的参数类型。基于类似的理由，这些类型也不允许作为__collect_safe外部调用的返回值类型。

以下是合法的参数类型：

integer-8: 从-2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 2<sup>7</sup>  到 2<sup>8</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是signed char）。

unsigned-8: 从 -2<sup>7</sup> 到 2<sup>8</sup> - 1 的整数有效。 -2<sup>7</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xff。参数作为一个合适大小的整数类型传递给C（通常是unsigned char）。

integer-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。2<sup>15</sup>  到 2<sup>16</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffff 是 -1。参数作为一个合适大小的整数类型传递给C (通常是short)。

unsigned-16: 从 -2<sup>15</sup> 到 2<sup>16</sup> - 1 的整数有效。-2<sup>15</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffff。参数作为一个合适大小的整数类型传递给C (通常是 unsigned short)。

integer-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。2<sup>31</sup>  到 2<sup>32</sup> - 1 范围内的整数被认为是负数的补充表示，如 #xffffffff 是 -1。参数作为一个合适大小的整数类型传递给C（通常是int）。

unsigned-32: 从 -2<sup>31</sup> 到 2<sup>32</sup> - 1 的整数有效。-2<sup>31</sup> 到 -1范围内的整数被认为是整数的补充表示，如 -1 是 #xffffffff. 参数作为一个合适大小的整数类型传递给C（通常是unsigned int）。

integer-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。2<sup>63</sup>  到 2<sup>64</sup> - 1 范围内的整数被认为是负数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是long long，或者在许多64位机器上long）。

unsigned-64: 从 -2<sup>63</sup> 到 2<sup>64</sup> - 1 的整数有效。-2<sup>63</sup> 到 -1范围内的整数被认为是整数的补充表示。参数作为一个合适大小的整数类型传递给C（通常是unsigned long long，或者在许多64位机器上unsigned long）(译者注：原文为long）。

double-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为双精度double类型传递给C。

single-float: 只有Scheme flonums有效--其他Scheme数值类型不会自动转换。参数作为单精度float类型传递给C。由于Chez Scheme以double-float类型表示flonums，参数首先会转换到single-float格式。

short: 该类型是以上合适固定大小类型的别名，取决于C中short的大小。

unsigned-short: 该类型是以上合适固定大小类型的别名，取决于C中unsigned short的大小。

int: 该类型是以上合适固定大小类型的别名，取决于C中int的大小。

unsigned: 该类型是以上合适固定大小类型的别名，取决于C中unsigned的大小。

unsigned-int: 该类型是unsinged类型的别名。固定大小类型，取决于C中unsigned的大小。

long: 该类型是以上合适固定大小类型的别名，取决于C中long的大小。

unsigned-long: 该类型是以上合适固定大小类型的别名，取决于C中unsigned long的大小。

long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中long long的大小。

unsigned-long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C中unsigned long long的大小。

ptrdiff_t: 该类型是以上合适固定大小类型的别名，取决于在宿主机器stddef.h头文件中的定义。

size_t: 该类型是以上合适固定大小无符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

ssize_t: 该类型是以上合适固定大小有符号类型的别名，取决于在宿主机器stddef.h头文件中的定义。

iptr: 该类型是以上合适固定大小类型的别名，取决于C中指针类型的大小。

uptr: 该类型是以上合适固定大小（无符号）类型的别名，取决于C中指针类型的大小。

void*: 该类型是uptr的别名。

fixnum: 该类型等效于iptr，除了在fixnum范围内的数值有效。传输fixnums比传输iptr值稍微快一点，但是fixnum的范围更小，所以有效iptr值没有fixnum的表示。

boolean: 任何Scheme对象可以被当做boolean传递。#f会被转换为0。所有其他对象被转换为1。参数以int类型传递给C。

char: 只有Scheme字符和在0~255范围的Unicode标量值是有效char参数。字符通过char->integer被转换为Unicode标量值，以unsigned char类型传递给C。

wchar_t: 只有Scheme的字符是有效wchar_t参数。在Windows和其他任何wchar_t只有16bit值而不是所有Unicode标量值的系统中，只有16bit Unicode标量值的字符有效。在wchar_t时32bit值得系统中，任何Scheme字符是有效的。字符通过char->integer被转换成Unicode标量值，以wchar_t类型传递给C。

wchar: 该类型是wchar_t的别名。

double: 该类型是double-float的别名。

float: 该类型是single-float的别名。

scheme-object: 该参数直接传递给外部过程；没有转换，没有类型检查。这种形式的参数传递应该被谨慎使用。Scheme objects不该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用的间隙重定位它们。

ptr: 该类型是scheme-object的别名。

u8*: 该参数必须是Scheme bytevector或者#f类型。对于#f，null pointer (0)被传递给外部过程。对于bytevector，指向bytevector数据的第一个字节的指针被传递给外部过程。如果被传递数据的C程序要求输入以'\0'结尾，那么 null (0)字节必须被显示包含在bytevector中。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。

u16*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么两个null (0)字节必须被显示包含在bytevector中，以16bit边界对齐。

u32*: 可把该类型的参数与u8*类型的参数同样看待。如果被传递数据的C程序要求输入以'\0'结尾，那么四个null (0)字节必须被显示包含在bytevector中，以32bit边界对齐。

utf-8: 该参数必须是Scheme string类型或者#f。对于#f，null pointer (0)被传递给外部过程。string被转换成bytevector，好像通过string-utf8一样，增加了null字节，第一个bytevector第一个字节的地址被传递给C。bytevector不应该被保存在外部变量或数据结构中，因为内存管理系统会在外部函数调用间隙重定位或丢去它们，把它们的储存空间另做他用。__collect_safe指定的外部过程不允许utf-8参数类型。

utf-16le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness little方式，后面追加了两个null字节而不是一个。

utf-16be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf16转换一样，以endianness big方式，后面追加了两个null字节而不是一个。

utf-32le: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness little方式，后面追加了四个null字节而不是一个。

utf-32be: 可把该类型的参数与utf-8类型的参数同样看待，除了他们好像通过string->utf32转换一样，以endianness big方式，后面追加了四个null字节而不是一个。

string: 该类型是utf-8的别名。

wstring: 该类型是utf-16le，utf-16be，utf-32le，或utf-32be的别名，取决于C中wchar_t的大小和目标机器的endianness。例如，在Intel处理器的Windows系统中wstring等效于utf-16le。

(* ftype): 该类型允许外部类型ftype的指针被传递。参数必须是类型ftype的ftype指针，真实的参数是ftype指针所封装的地址。见4.5节外部类型描述。

(& ftype): 该类型允许外部类型ftype以值得形式传递，但是在Scheme方面是以外部类型数据的指针方式。也就是说， (& ftype) 参数在Scheme方面与 (* ftype) 参数一样，但是 (& ftype) 参数是以外部指针地址中的内容而非地址传递给外部过程。例如，如果ftype是struct类型，那么(& ftype)传递struct参数而不是struct-pointer参数。ftype不能引用array类型。

返回值类型和参数类型情况类似，增加了一个void类型。一般来说，类型转换是参数类型转换的逆过程。在返回时灭有错误检查，应为系统不能决定一个外部结果是否真的是其所指示的类型。在使用过程中需要特别注意scheme-object, double-float, double, single-float, float和会创建bytevectors或strings的类型，因为无效的返回值可能会导致不正确的内存引用和不正确的计算。以下是有效的返回值类型：

void: 外部函数过程的返回值被忽略，未指定的Scheme对象被返回。void 用于只是产生效果的外部过程的调用。

integer-8: 结果被解译为signed 8-bit integer，并转换为Scheme exact integer。

unsigned-8: 结果被解译为unsigned 8-bit integer，并转换为Scheme非负exact integer。

integer-16: 结果被解译为signed 16-bit integer，并转换为Scheme exact integer。

unsigned-16: 结果被解译为unsigned 16-bit integer，并转换为Scheme非负exact integer。

integer-32: 结果被解译为signed 32-bit integer，并转换为Scheme exact integer。

unsigned-32: 结果被解译为unsigned 32-bit integer，并转换为Scheme非负exact integer。

integer-64: 结果被解译为signed 64-bit integer，并转换为Scheme exact integer。

unsigned-64: 结果被解译为unsigned 64-bit integer，并转换为Scheme非负exact integer。

double-float: 结果被解译为双精度浮点型double float，并被转换为Chez Scheme flonum。

single-float: 结果被解译为双精度浮点型single float，并被转换为Chez Scheme flonum。因为Chez Scheme用double-float格式表示flonums，结果首先被转换成double-float格式。

short: 该类型是以上合适固定大小类型的别名，取决于C short的大小。

unsigned-short: 该类型是以上合适固定大小类型的别名,取决于C unsigned short大小。

int: 该类型是以上合适固定大小类型的别名，取决于C int的大小。

unsigned: 该类型是以上合适固定大小类型的别名，取决于C unsigned的大小。

unsigned-int: 该类型是以上合适固定大小类型unsigned的别名，取决于C unsigned的大小。

long: 该类型是以上合适固定大小类型的别名，取决于C long的大小。

unsigned-long: 该类型是以上合适固定大小类型的别名，取决于C unsigned long的大小。

long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C long long的大小。

unsigned-long-long: 该类型是以上合适固定大小类型的别名，取决于非标准C unsigned long long的大小。

ptrdiff_t: 该类型是以上合适固定大小类型的别名，取决于宿主机器stddef.h头文件中的定义。

size_t: 该类型是以上合适固定大小unsigned类型的别名，取决于宿主机器stddef.h头文件中的定义。

ssize_t: 该类型是以上合适固定大小signed类型的别名，取决于宿主机器stddef.h头文件中的定义。

iptr: 该类型是以上合适固定大小类型的别名，取决于C中指针的大小。

uptr: 该类型是以上合适固定大小(unsigned)类型的别名，取决于C中指针的大小。

void*: 该类型是uptr的别名。

boolean: 该类型把C int返回值转换为Scheme boolean。0为#f，其他值为#t。

char: 该类型把C unsigned char类型转换为Scheme character，就像通过integer->char。

wchar_t: 该类型把C wchar_t返回值转化为Scheme character，就像通过integer->char。wchar_t值必须是一个有效地Unicode标量值。

wchar: 该类型是wchar_t的别名。

double: 该类型是double-float的别名。

float: 该类型是single-float的别名。

scheme-object: 结果被假设为一个有效的Scheme object，不进行转换。该类型具有危险性，因为无效的Scheme object会导致内存管理系统不确定的错误结果（通常是不不好的）。由于Scheme object实际上是typed指针，甚至integers也不能安全地被返回为scheme-object，除非他们是由Scheme系统创建的。

ptr: 该类型是scheme-object的别名。

u8*: 结果被解译为一个'\0'结尾的8-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。

u16*: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，16-bit integers序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。null 结尾符为16 bit对齐，即两个字节的16-bit对齐边界。

u32*: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，32-bit integers序列被储存在新分配的合适长度的bytevector中，bytevector被返回给Scheme。null 结尾符为32-bit对齐，即四个字节的32-bit对齐边界。(译者注：原文为the sequence of 16-bit integers)

utf-8: 结果被解译为一个'\0'结尾的8-bit unsigned character序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string类型，就像通过utf8->string，string返回给Scheme。

utf-16le: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf16->string，以endianness little方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-16be: 结果被解译为一个'\0'结尾的16-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf16->string，以endianness big方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-32le: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf32->string，以endianness little方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

utf-32be: 结果被解译为一个'\0'结尾的32-bit unsigned integers序列的指针。如果结果是空指针，返回为#f。否则，字节序列被转换为Scheme string,就像通过utf32->string，以endianness big方式，string返回给Scheme。在integers序列中的字节序标记被认为是普通字符值，不影响字节序。

string: 该类型是utf-8的别名。

wstring: 该类型是utf-16le, utf-16be, utf-32le, utf-32be中合适类型的别名，取决于C中wchar_t的大小和目标机器的endianness。例如，wstring在Intel硬件的Windows系统上等效于utf-16le。

(* ftype): 结果被解译为外部对象的地址，其由ftype描述，新分配的封装该地址的ftype指针被返回。见4.5节对外部类型的描述。

(& ftype): 结果被解译为外部对象，其由ftype描述，外部函数返回一个ftype结果，但是，调用者必须在其他调用参数前提供一个额外的(* ftype)参数来接收结果。外部过程调用后一个未指定的Scheme对象被返回，因为结果被写入由额外参数引用的储存空间中。ftype不能引用array类型。

我们看下C identity过程：

`int id(x) int x; { return x; }`

当包含该过程的文件被编译加载（见4.6），它能够由以下方式访问：

```
(foreign-procedure "id"
  (int) int)
=> #<procedure>
((foreign-procedure "id"
   (int) int)
 1)
=> 1
(define int-id
  (foreign-procedure "id"
    (int) int))
(int-id 1)
=> 1
```

“id”入口能够被解译为接收和返回boolean类型：

```
(define bool-id
  (foreign-procedure "id"
    (boolean) boolean))
(bool-id #f)
=> #f
(bool-id #t)
=> #t
(bool-id 1)
=> #t
```

如上例所揭示的，bool-id实际上是转换过程。当Scheme对象以类型boolean传递时，其被转换为0或1，当其返回时被转换为#f或#t。结果被转换成规范化的boolean值。通过变换类型指定，“id”入口能够被用来创建其他转换过程。

```
(define int->bool
  (foreign-procedure "id"
    (int) boolean))
(int->bool 0)
=> #f
(int->bool 5)
=> #t
(map (foreign-procedure "id"
       (boolean) int)
     '(#t #f))
=> (1 0)

(define void
  (foreign-procedure "id"
    (int) void))
(void 10)
=> unspecified
```

当然在Scheme中有更加简单、高效的直接完成转换的方式。

当foreign-procedure表达式被求值时外部入口被解析，而不是代码被加载或者每次调用时。因此，以下定义总是有效地，因为foreign-procedure表达式不是立即被求值：

```
(define doit
  (lambda ()
    ((foreign-procedure "doit" () void))))
```

在“doit”的入口未被提供前，doit不应该被调用。类似地，“doit”的入口必须在以下代码求值前存在。

```
(define doit
  (foreign-procedure "doit" () void))
```

尽管第二种定义更加限制外部文件的加载顺序，但是更加有效率，因为入口解析只需要做一次。

定义一个模板用于创建几个具有类似参数类型和返回值的外部过程，这通常很有用。例如，以下代码从一个外部过程表达式创建两个外部过程，通过抽象出外部过程名字：

```
(define double->double
  (lambda (proc-name)
    (foreign-procedure proc-name
      (double)
      double)))

(define log10 (double->double "log10"))
(define gamma (double->double "gamma"))
```

在对应的定义之前，“log10”和“gamma”都必须存在外部入口（见4.6节）。使用外部过程模板能够简化编码过程，减少需要生成大量外部过程所使用的代码量，例如，当整个库的外部过程被导入到Scheme中。

## 4.3 从Scheme导出（Calling into Scheme）

4.2节描述了foreign-procedure形式，其允许Scheme代码调用C或C兼容外部过程。该节描述foreign-callable形式，其允许C或C兼容代码调用Scheme过程。在C中调用Scheme过程的更原始的机理在4.8节描述。

当在外部调用Scheme过程时，Scheme和调用Scheme的外部代码之间共享数据要小心，防止破坏Scheme的内存管理系统。（译者注：原文为As when calling foreign procedures from Scheme）。

通过传递过程给make-ftype-pointer，并使用合适的函数ftype（见4.5节），能够创建Scheme过程的foreign-callable封装。

*syntax*: (foreign-callable conv ... proc-exp (param-type ...) res-type)
*returns*: 代码对象
libraries: (chezscheme)

proc-exp必须是过程，是一个被用于外部代码调用的Scheme过程。参数类型和返回值类型如4.2节的foreign-procedure中介绍的，除了要求和转换是相反的，即对于foreign-procedure参数的描述适用于foreign-callable的返回值描述。callable的(& ftype)参数引用了一个只有在callback调用的动态范围中有效的地址。callable的(& ftype)返回值类型需要Scheme过程在所有其他参数前面额外接收一个(& ftype)参数。Scheme过程应该将结果写入这个额外的参数，Scheme过程的直接结果被抛弃。类型检查针对返回值而不是参数类型，因为参数值由外部代码提供，必须假设其是正确的。

每一个conv调整其使用的调用规则。foreign-callable支持与foreign-procedure一样的调用规则，除了__com。callable的__collect_safe调用规则会将没有激活的调用线程激活，当callable返回时，线程的激活状态将恢复。如果调用线程当前没有在Scheme系统中注册，那么恢复线程激活状态指的是销毁该线程的注册（见Sdestroy_thrread）。

由foreign-callable产生的值是一个Scheme code对象，其包含一些头信息和中包装的Scheme可执行过程。code对象可通过foreign-callable-entry-point转换为foreign-callable的地址，返回一个代表code对象入口地址的整数。（C-callcalbe库函数Sforeign_callable_entry_point，在4.8节介绍，也能够被用来获取入口。）这是一个Scheme对象的隐式指针，在许多情况下，在转换成入口之前必须锁住code对象（使用lock-object）以防止Scheme内存管理系统重新定位或者销毁code对象，即当入口被注册为callback，可以在C中保持永久使用。

以下代码创建得了foreign-callable code对象，锁住code对象，返回入口。

```
(let ([x (foreign-callable
           (lambda (x y) (pretty-print (cons x (* y 2))))
           (string integer-32)
           void)])
  (lock-object x)
  (foreign-callable-entry-point x))
```

由foreign-callable返回的code对象的指针可以再不需要的时候解锁，除非入口需要永久保留。

foreign-callable和foreign-procedure的混合使用会导致外部代码和Scheme调用的嵌套，当涉及到延续(continuations)时会产生有意思的思考，无论这是直接还是间接的(由于通过默认异常处理)。见4.4节中关于外部调用和延续(continuations)的交互。

以下例子展示了在Scheme中使用foreign-callable定义许多窗口系统需要的回调函数。假设以下C代码已经被编译和加载（见4.6节）。

```
#include <stdio.h>

typedef void (*CB)(char);

CB callbacks[256];

void cb_init(void) {
   int i;

   for (i = 0; i < 256; i += 1)
       callbacks[i] = (CB)0;
}

void register_callback(char c, CB cb) {
    callbacks[c] = cb;
}

void event_loop(void) {
    CB f; char c;

    for (;;) {
        c = getchar();
        if (c == EOF) break;
        f = callbacks[c];
        if (f != (CB)0) f(c);
    }
}
```

这些函数的接口可以在Scheme中如下定义。

```
(define cb-init
  (foreign-procedure "cb_init" () void))
(define register-callback
  (foreign-procedure "register_callback" (char void*) void))
(define event-loop
  (foreign-procedure __collect_safe "event_loop" () void))
```

选择字符的回调函数能在后面定义。

```
(define callback
  (lambda (p)
    (let ([code (foreign-callable __collect_safe p (char) void)])
      (lock-object code)
      (foreign-callable-entry-point code))))
(define ouch
  (callback
    (lambda (c)
      (printf "Ouch! Hit by '~c'~%" c))))
(define rats
  (callback
    (lambda (c)
      (printf "Rats! Received '~c'~%" c))))

(cb-init)
(register-callback #\a ouch)
(register-callback #\c rats)
(register-callback #\e ouch)
```

这样就建立了如下的交互。

```
> (event-loop)
a
Ouch! Hit by 'a'
b
c
Rats! Received 'c'
d
e
Ouch! Hit by 'e'
```

该例子中的__collect_saft声明确保当event-loop等待输入阻塞时其他线程能够继续工作。一个更好的该例子的版本应该保存每个由foreign-callable返回的code对象，当回调函数不再注册时对它们解除锁定。

*procedure*: (foreign-callable-entry-point code)
*returns*: code对象中foreign-callable的地址
*libraries*: (chezscheme)

code是foreign-callable产生的code对象。

*procedure*: (foreign-callable-code-object address)
*returns*: foreign-callable的入口地址对应的code对象
*libraries*: (chezscheme)

地址必须是exact integer且必须是由foreign-callable产生的code对象的入口的地址。

## 4.4 延续和外部调用（Continuations and Foreign Calls）

foreign-callable和foreign-procedure 允许任意地嵌套外部和Scheme调用。因为其他语言不完全支持Scheme的通用头等延续（general first-class continuations），延续(continuations)间的交互和Scheme与外部过程的嵌套调用是易发生问题的。Chez Scheme使用通用的陷入方式(trapping)尝试返回到旧外部上下文（stale foreign context）来处理交互，而不是直接限制延续（continuations）的使用。外部上下文是一个外部帧（foreign frame）和来自外部函数特定调用的返回点，例如，从C进入Scheme。在一个平常的返回到上下文或者返回到控制栈上的在其下面的其他外部上下文后，外部上下文将变旧。

这样处理的结果是，Scheme延续逻辑上能被用来释放控制权，无论是向上或者向下，通过任意混合Scheme和外部帧的方式。更进一步讲，直到返回外部上下文被真正执行，所有的返回点都是有效地。特别的，这表示使用延续的程序，除了非局部退出的情况，绝不会尝试返回到一个旧外部上下文。（非局部退出本身并没有问题，是由C函数库longjmp及其等效方式实现的）。使用延续的程序只要它们绝不真正返回到一个旧外部上下文一般都能够正常地工作，即使通过延续的调用，在逻辑上控制越过了旧上下文。

一种该机制的结果会是：当Scheme端使用了延续时，非局部退出情况下，C栈指针不会自动恢复其基值（base value）。如果程序在非局部退出后继续运行的话，后面建立的C栈会被增加到已经存在的栈上，可能会导致C栈溢出。为了避免该情况的发生，程序可以在获取延续之前安排建立一个单独的C调用帧，在非局部退出后返回到该C帧。下面的with-exit_-proc过程就是安排做这个，并且不涉及到C代码。

```
(define with-exit-proc
  (lambda (p)
    (define th (lambda () (call/cc p)))
    (define-ftype ->ptr (function () ptr))
    (let ([fptr (make-ftype-pointer ->ptr th)])
      (let ([v ((ftype-ref ->ptr () fptr))])
        (unlock-object
          (foreign-callable-code-object
            (ftype-pointer-address fptr)))
        v))))
```

除了当延续被调用时会重置C的栈，with-exit-proc类似call/cc。为了实现这个，其创建了th的一个ftype-pointer来表示foreign-callable入口，并创建了一个Scheme可调用过程的入口。这为th建立了一个涉及C调用的封装。当该封装返回时，无论是通过显示的延续调用传递p，还是一般地从p返回，C栈都会被重置为原始值。

## 4.5 外部数据

## 4.6 访问外部过程

可以通过以下几种方式获得外部过程：

可以使用加载动态链接库过程 load-shared-object 加载外部过程。
一个新的Chez Scheme映像可以用加载外部代码构建的方式链接。Sforeign_symbol Sregister_symbol 参见4.8
其他条目可以动态加载或以其他方式由外部代码获得。通常也使用Sforeign_symbol Sregister_symbol进行注册。
入口地址，比如函数指针，可以被传递给Scheme，并用作外部过程表达式中入口语句的值。即使没有按照名称注册，也可以使用外部入口点。
过程：(foreign-entry? entry-name）
返回：如果entry-name存在，返回#t，否则#f
库：(chezscheme)
entry-name 必须是 string，可用于确定是否存在外部程序的过程。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
foreign-entry? "strlen"）#  => t 
    ((foreign-procedure "strlen" 
    (string) size_t)
 "hey!"）  => 4
 ```
过程：(foreign-entry entry-name)
返回：以integer返回entry-name名称的address
库：(chezscheme)
入口名称必须是一个命名现有外来入口点的字符串。

以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。

```
(let ([addr (foreign-entry "strlen")])
    (and (integer? addr) (exact? addr))) => #t 

(define-ftype strlen-type (function (string) size_t))
(define strlen
    (ftype-ref strlen-type ()
    (make-ftype-pointer strlen-type "strlen")))
(strlen "hey!") => 4
```
过程：(foreign-address-name address)
返回：address对应的entry-name。若不存在，返回#f
库：(chezscheme)
以下示例假定定义strlen的库已经通过load-shared-object加载，或者strlen已经通过本节中介绍的其他方法注册。
```
(foreign-address-name (foreign-entry "strlen")) => "strlen"
```
过程：(load-shared-object path)
返回：unspecified
库：(chezscheme)
path必须是一个字符串。load-shared-object加载由path指定的动态链接库。动态链接库可能是系统库或从普通C程序创建的文件。动态链接库中的所有外部符号以及与shared-object链接的其他动态链接库中可用的外部符号都可用作外部条目。

在Chez Scheme运行的大多数平台上都支持这个过程。

如果path不以"."或者"/"开始，shared-object将在系统默认的环境变量中进行搜索。

在大多数Unix系统上，load-shared-object基于系统例程dlopen。在Windows下，load-shared-object基于LoadLibrary。有关这些例程的文档，请参阅C编译器和加载器，以获取有关查找和构建动态链接库的精确规则。

load-shared-object可以用来访问内置的C库函数，比如getenv。动态链接库的名称因系统而异，在Linux系统上：

`（load-shared-object "libc.so.6"）`

在Solaris，OpenSolaris，FreeBSD，NetBSD和OpenBSD系统上：

`（load-shared-object "libc.so"）`

在MacOS X系统上：

`(load-shared-object "libc.dylib")`
在Windows上：

`(load-shared-object "crtdll.dll")`
一旦C库被加载，getenv应该可以作为一个外部入口：

`(foreign-entry? "getenv") => #t`
可以这样定义和调用等效的Scheme过程：
```
(define getenv
    (foreign-procedure "getenv"
        (string)
        string))
(getenv "HOME") => "/home/elmer/fudd"
(getenv "home") => #f
```
load-shared-object也可以用来访问用户创建的库，

假设C文件"env.c"包含

int even(n) int n; { return n == 0 || odd(n - 1); }
C文件"odd.c"包含

int odd(n) int n; { return n != 0 && even(n - 1); }
这些文件必须被编译并链接到动态链接库才能被加载。其过程取决于系统：

在Linux，FreeBSD，OpenBSD和OpenSolaris上：

(system "cc -fPIC -shared -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在MacOS X（Intel或PowerPC）系统上：

(system "cc -dynamiclib -o evenodd.so even.c odd.c")
根据主机配置的不同，可能需要 -m32 或 -m64 选项来指定32位或64位编译。

在32位Sparc Solaris上：

(system "cc -KPIC -G -o evenodd.so even.c odd.c")
在64位Sparc Solaris上：

(system "cc -xarch=v9 -KPIC -G -o evenodd.so even.c odd.c")
在Windows上，我们构建一个DLL（动态链接库）文件。为了使编译器生成适当的入口点，我们改变even.c来读取

```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif
```
EXPORT int even(n) int n; { return n == 0 || odd(n - 1); }
和odd.c读取
```
#ifdef WIN32
#define EXPORT extern __declspec (dllexport)
#else
#define EXPORT extern
#endif
```
EXPORT int odd(n) int n; { return n != 0 && even(n - 1); }
然后，我们可以按如下所示构建DLL，并为其提供扩展名“.so”而不是“.dll”，以便与其他系统保持一致。
```
(system "cl -c -DWIN32 even.c")
(system "cl -c -DWIN32 odd.c")
(system "link -dll -out:evenodd.so even.obj odd.obj")
```
生成的“.so”文件可以加载到Scheme中，even和odd可以作为外部过程使用：
```
(load-shared-object "./evenodd.so")
(let ([odd (foreign-procedure "odd"
             (integer-32) boolean)]
      [even (foreign-procedure "even"
              (integer-32) boolean)])
  (list (even 100) (odd 100))) => (#t #f)
```
文件名以“./evenodd.so”定义，而不是简单的“evenodd.so”，因为有些系统在不包含当前目录的标准系统目录集中查找共享库。

过程：(remove-foreign-entry entry-name) 
返回：unspecified 
库： (chezscheme)
remove-foreign-entry将访问由entry-name指定的入口。如果目标不存在，就会引发异常。可在外部接口建立后用remove-foreign-entry而不影响之前由foreign-procedure建立的接口访问。

使用remove-foreign-entry可删除使用Sforeign_symbol和Sregister_symbol注册的条目，但不能删除由调用load-shared-object而创建的条目。

##4.7 使用其他的编程语言

尽管Chez Scheme外部过程接口主要面向C中定义的过程或C库中可用的过程，但也可以调用其他语言中遵循C调用约定的过程。一个难点可能来自名字解析。基于Unix的C编译器通常会在外部名前加一个下划线，外部接口尝试以与主机C编译器一致的方式解释入口名。偶尔，如汇编代码文件，这个条目的名称可能不以被期望的方式解析。通过在入口名前添加一个“=”字符可防止。 例如，加载包含过程“foo”的汇编文件后，可能会有

```
（foreign-entry？“foo”） => #f
（foreign-entry？“=foo”）=> #t
```

##4.8 C库过程

Additional foreign interface support is provided via a set of C preprocessor macros and C-callable library functions. Some of these routines allow C programs to examine, allocate, and alter Scheme objects. Others permit C functions to call Scheme procedures via a more primitive interface than that defined in Section 4.3. Still others permit the development of custom executable images and use of the Scheme system as a subordinate program within another program, e.g., for use as an extension language.

C code that uses these routines must include the "scheme.h" header file distributed with Chez Scheme and must be linked (statically or dynamically) with the Chez Scheme kernel. The header file contains definitions for the preprocessor macros and extern declarations for the library functions. The file is customized to the release of Chez Scheme and machine type with which it is distributed; it should be left unmodified to facilitate switching among Chez Scheme releases, and the proper version of the header file should always be used with C code compiled for use with a particular version of Chez Scheme. The version and machine type are defined in "scheme.h" under the names VERSION and MACHINE_TYPE.

The name of each routine begins with a capital S, e.g., Sfixnump. Many of the names are simple translations of the names of closely related Scheme procedures, e.g., Sstring_to_symbol is the C interface equivalent of string->symbol. Most externally visible entries in the Chez Scheme executable that are not documented here begin with capital S followed by an underscore (S_); their use should be avoided.

In addition to the various macros and external declarations given in scheme.h, the header file also defines (typedefs) several types used in the header file:

ptr: type of a Scheme value,
iptr: a signed integer the same size as a Scheme value, and
uptr: an unsigned integer the same size as a Scheme value.
string_char: type of a single Scheme string element.
octet: type of a single Scheme bytevector element (unsigned char).
These types may vary depending upon the platform, although ptr is typically void *, iptr is typically long int, and uptr is typically unsigned long int.

Under Windows, defining SCHEME_IMPORT before including scheme.h causes scheme.h to declare its entry points using extern declspec (dllimport) rather than extern declspec (dllexport) (the default). Not defining SCHEME_IMPORT and instead defining SCHEME_STATIC causes scheme.h to declare exports using just extern. The static libraries distributed with Chez Scheme are built using SCHEME_STATIC.

The remainder of this section describes each of the C interface routines in turn. A declaration for each routine is given in ANSI C function prototype notation to precisely specify the argument and result types. Scheme objects have the C type ptr, which is defined in "scheme.h". Where appropriate, C values are accepted as arguments or returned as values in place of Scheme objects.

The preprocessor macros may evaluate their arguments more than once (or not at all), so care should be taken to ensure that this does not cause problems.

Customization.  The functions described here are used to initialize the Scheme system, build the Scheme heap, and run the Scheme system from a separate program.

[func] char * Skernel_version(void)
[func] void Sscheme_init(void (*abnormal_exit)(void))
[func] void Sset_verbose(int v)
[func] void Sregister_boot_file(const char *name)
[func] void Sregister_boot_file_fd(const char *name, int fd)
[func] void Sbuild_heap(const char *exec, void (*custom_init)(void))
[func] void Senable_expeditor(const char *history_file)
[func] void Sretain_static_relocation(void)
[func] int Sscheme_start(int argc, char *argv[])
[func] int Sscheme_script(char *scriptfile, int argc, char *argv[])
[func] int Sscheme_program(char *programfile, int argc, char *argv[])
[func] void Scompact_heap(void)
[func] void Sscheme_deinit(void)
Skernel_version returns a string representing the Scheme version. It should be compared against the value of the VERSION preprocessor macro before any of the initialization functions listed above are used to verify that the correct "scheme.h" header file has been used.

Sscheme_init causes the Scheme system to initialize its static memory in preparation for boot file registration. The abnormal_exit parameter should be a (possibly null) pointer to a C function of no arguments that takes appropriate action if the initialization or subsequent heap-building process fails. If null, the default action is to call exit(1).

Sset_verbose sets verbose mode on for nonzero values of v and off when v is zero. In verbose mode, the system displays a trace of the search process for subsequently registered boot files.

Sregister_boot_file searches for the named boot file and register it for loading, while Sregister_boot_file_fd provides a specific boot file as a file descriptor. When only a boot file name is provided, the file is opened but not loaded until the heap is built via Sbuild_heap. When a file descriptor is provided, the given file name is used only for error reporting. For the first boot file registered only, the system also searches for the boot files upon which the named file depends, either directly or indirectly.

Sbuild_heap creates the Scheme heap from the registered boot files. exec is assumed to be the name of or path to the executable image and is used when no boot files have been registered as the base name for the boot-file search process. exec may be null only if one or more boot files have been registered. custom_init must be a (possibly null) pointer to a C function of no arguments; if non-null, it is called before any boot files are loaded.

Sscheme_start invokes the interactive startup procedure, i.e., the value of the parameter scheme-start, with one Scheme string argument for the first argc elements of argv, not including argv[0]. Sscheme_script similarly invokes the script startup procedure, i.e., the value of the parameter scheme-script, with one Scheme string argument for scriptfile and the first argc elements of argv, not including argv[0]. Sscheme_program similarly invokes the program startup procedure, i.e., the value of the parameter scheme-program, with one Scheme string argument for programfile and the first argc elements of argv, not including argv[0].

Senable_expeditor enables the expression editor (Section 2.2, Chapter 14), which is disabled by default, and determines the history file from which it restores and to which it saves the history. This procedure must be called after the heap is built, or an error will result. It must also be called before Sscheme_start in order to be effective. If the history_file argument is the null pointer, the history is not restored or saved. The preprocessor variable FEATURE_EXPEDITOR is defined in scheme.h if support for the expression editor has been compiled into the system.

Sretain_static_relocation causes relocation information to be retained for static generation code objects created by heap compaction for the benefit of compute-size and related procedures.

Scompact_heap compacts the Scheme heap and places all objects currently in the heap into a static generation. Objects in the static generation are never collected. That is, they are never moved during collection and the storage used for them is never reclaimed even if they become inaccessible. Scompact_heap is called implicitly after any boot files have been loaded.

Sscheme_deinit closes any open files, tears down the Scheme heap, and puts the Scheme system in an uninitialized state.

Predicates.  The predicates described here correspond to the similarly named Scheme predicates. A trailing letter p, for "predicate," is used in place of the question mark that customarily appears at the end of a Scheme predicate name. Each predicate accepts a single Scheme object and returns a boolean (C integer) value.

[macro] int Sfixnump(ptr obj)
[macro] int Scharp(ptr obj)
[macro] int Snullp(ptr obj)
[macro] int Seof_objectp(ptr obj)
[macro] int Sbwp_objectp(ptr obj)
[macro] int Sbooleanp(ptr obj)
[macro] int Spairp(ptr obj)
[macro] int Ssymbolp(ptr obj)
[macro] int Sprocedurep(ptr obj)
[macro] int Sflonump(ptr obj)
[macro] int Svectorp(ptr obj)
[macro] int Sbytevectorp(ptr obj)
[macro] int Sfxvectorp(ptr obj)
[macro] int Sstringp(ptr obj)
[macro] int Sbignump(ptr obj)
[macro] int Sboxp(ptr obj)
[macro] int Sinexactnump(ptr obj)
[macro] int Sexactnump(ptr obj)
[macro] int Sratnump(ptr obj)
[macro] int Sinputportp(ptr obj)
[macro] int Soutputportp(ptr obj)
[macro] int Srecordp(ptr obj)
Accessors.  Some of the accessors described here correspond to similarly named Scheme procedures, while others are unique to this interface. Sfixnum_value, Schar_value, Sboolean_value, and Sflonum_value return the C equivalents of the given Scheme value.

[macro] iptr Sfixnum_value(ptr fixnum)
[macro] uptr Schar_value(ptr character)
[macro] int Sboolean_value(ptr obj)
[macro] double Sflonum_value(ptr flonum)
Sinteger_value and Sunsigned_value are similar to Sfixnum_value, except they accept not only fixnum arguments but bignum arguments in the range of C integer or unsigned values. Sinteger_value and Sunsigned_value accept the same range of Scheme integer values. They differ only in the result type, and so allow differing interpretations of negative and large unsigned values.

[func] iptr Sinteger_value(ptr integer)
[macro] uptr Sunsigned_value(ptr integer)
Sinteger32_value, Sunsigned32_value, Sinteger64_value, and Sunsigned64_value accept signed or unsigned Scheme integers in the 32- or 64-bit range and return integers of the appropriate type for the machine type.

[func] <32-bit int type> Sinteger32_value(ptr integer)
[macro] <32-bit unsigned type> Sunsigned32_value(ptr integer)
[func] <64-bit int type> Sinteger64_value(ptr integer)
[macro] <64-bit unsigned type> Sunsigned64_value(ptr integer)
Scar, Scdr, Ssymbol_to_string (corresponding to symbol->string), and Sunbox are identical to their Scheme counterparts.

[macro] ptr Scar(ptr pair)
[macro] ptr Scdr(ptr pair)
[macro] ptr Ssymbol_to_string(ptr sym)
[macro] ptr Sunbox(ptr box)
Sstring_length, Svector_length, Sbytevector_length, and Sfxvector_length each return a C integer representing the length (in elements) of the object.

[macro] iptr Sstring_length(ptr str)
[macro] iptr Svector_length(ptr vec)
[macro] iptr Sbytevector_length(ptr bytevec)
[macro] iptr Sfxvector_length(ptr fxvec)
Sstring_ref, Svector_ref, Sbytevector_u8_ref, and Sfxvector_ref correspond to their Scheme counterparts, except that the index arguments are C integers, the return value for Sstring_ref is a C character, and the return value for Sbytevector_u8_ref is an octet (unsigned char).

[macro] char Sstring_ref(ptr str, iptr i)
[macro] ptr Svector_ref(ptr vec, iptr i)
[macro] octet Sbytevector_u8_ref(ptr fxvec, iptr i)
[macro] ptr Sfxvector_ref(ptr fxvec, iptr i)
A Scheme bytevector is represented as a length field followed by a sequence of octets (unsignec chars). Sbytevector_data returns a pointer to the start of the sequence of octets. Extreme care should be taken to stop dereferencing the pointer returned by Sbytevector_data or to lock the bytevector into memory (see Slock_object below) before any Scheme code is executed, whether by calling into Scheme or returning to a Scheme caller. The storage manager may otherwise relocate or discard the object into which the pointer points and may copy other data over the object.

[macro] octet * Sbytevector_data(ptr bytevec)
Mutators.  Changes to mutable objects that contain pointers, such as pairs and vectors, must be tracked on behalf of the storage manager, as described in one of the references [13]. The operations described here perform this tracking automatically where necessary.

[func] void Sset_box(ptr box, ptr obj)
[func] void Sset_car(ptr pair, ptr obj)
[func] void Sset_cdr(ptr pair, ptr obj)
[macro] void Sstring_set(ptr str, iptr i, char c)
[func] void Svector_set(ptr vec, iptr i, ptr obj)
[macro] void Sbytevector_u8_set(ptr bytevec, iptr i, octet n)
[macro] void Sfxvector_set(ptr fxvec, iptr i, ptr fixnum)
Some Scheme objects, such as procedures and numbers, are not mutable, so no operators are provided for altering the contents of those objects.

Constructors.  The constructors described here create Scheme objects. Some objects, such as fixnums and the empty list, are represented as immediate values that do not require any heap allocation; others, such as pairs and vectors, are represented as pointers to heap allocated objects.

Snil, Strue, Sfalse, Sbwp_object, Seof_object, and Svoid construct constant immediate values representing the empty list ( () ), the boolean values (#t and #f), the broken-weak-pointer object (#!bwp), the eof object (#!eof), and the void object.

[macro] ptr Snil
[macro] ptr Strue
[macro] ptr Sfalse
[macro] ptr Sbwp_object
[macro] ptr Seof_object
[macro] ptr Svoid
Fixnums, characters, booleans, flonums, and strings may be created from their C equivalents.

[macro] ptr Sfixnum(iptr n)
[macro] ptr Schar(char c)
[macro] ptr Sboolean(int b)
[func] ptr Sflonum(double x)
[func] ptr Sstring(const char *s)
[func] ptr Sstring_of_length(const char *s, iptr n)
[func] ptr Sstring_utf8(const char *s, iptr n)
;

Sstring creates a Scheme copy of the C string s, while Sstring_of_length creates a Scheme string of length n and copies the first n bytes from s into the new Scheme string.

If the C string is encoded in UTF-8, use Sstring_utf8 instead. Specify the number of bytes to convert as n or use -1 to convert until the null terminator.

It is possible to determine whether a C integer is within fixnum range by comparing the fixnum value of a fixnum created from a C integer with the C integer:

#define fixnum_rangep(x) (Sfixnum_value(Sfixnum(x)) == x)

Sinteger and Sunsigned may be used to create Scheme integers whether they are in fixnum range or not.

[func] ptr Sinteger(iptr n)
[func] ptr Sunsigned(uptr n)
Sinteger and Sunsigned differ in their treatment of negative C integer values as well as C unsigned integer values that would appear negative if cast to integers. Sinteger converts such values into negative Scheme values, whereas Sunsigned converts such values into the appropriate positive Scheme values. For example, assuming a 32-bit, two's complement representation for iptrs, Sinteger(-1) and Sunsigned((iptr)0xffffffff) both evaluate to the Scheme integer -1, whereas Sunsigned(0xffffffff) and Sunsigned((uptr)-1) both evaluate to the Scheme integer #xffffffff (4294967295).

Whichever routine is used, Sinteger_value and Sunsigned_value always reproduce the corresponding C input value, thus the following are all equivalent to x if x is an iptr.

Sinteger_value(Sinteger(x))
(iptr)Sunsigned_value(Sinteger(x))
Sinteger_value(Sunsigned((uptr)x))
(iptr)Sunsigned_value(Sunsigned((uptr)x))

Similarly, the following are all equivalent to x if x is a uptr.

(uptr)Sinteger_value(Sinteger((iptr)x))
Sunsigned_value(Sinteger((iptr)x))
(uptr)Sinteger_value(Sunsigned(x))
Sunsigned_value(Sunsigned(x))

Sinteger32, Sunsigned32, Sinteger64, and Sunsigned64 are like the generic equivalents but restrict their arguments to the 32- or 64-bit range.

[func] ptr Sinteger32(<32-bit int type> n)
[func] ptr Sunsigned32(<32-bit unsigned type> n)
[func] ptr Sinteger64(<64-bit int type> n)
[func] ptr Sunsigned64(<64-bit unsigned type> n)
Scons and Sbox are identical to their Scheme counterparts.

[func] ptr Scons(ptr obj1, ptr obj2)
[func] ptr Sbox(ptr obj)
Sstring_to_symbol is similar to its Scheme counterpart, string->symbol, except that it takes a C string (character pointer) as input.

[func] ptr Sstring_to_symbol(const char *s)
Smake_string, Smake_vector, Smake_bytevector, and Smake_fxvector are similar to their Scheme counterparts.

[func] ptr Smake_string(iptr n, int c)
[func] ptr Smake_vector(iptr n, ptr obj)
[func] ptr Smake_bytevector(iptr n, int fill)
[func] ptr Smake_fxvector(iptr n, ptr fixnum)
Smake_uninitialized_string is similar to the one-argument make-string.

[func] ptr Smake_uninitialized_string(iptr n)
Windows-specific helper functions.  The following helper functions are provided on Windows only.

[func] char * Sgetenv(const char *name)
Sgetenv returns the UTF-8-encoded value of UTF-8-encoded environment variable name if found and NULL otherwise. Call free on the returned value when it is no longer needed.

[func] wchar_t * Sutf8_to_wide(const char *\s)
[func] char * Swide_to_utf8(const wchar_t *\s)
Sutf8_to_wide and Swide_to_utf8 convert between UTF-8-encoded and UTF-16LE-encoded null-terminated strings. Call free on the returned value when it is no longer needed.

Accessing top-level values.  Top-level variable bindings may be accessed or assigned via Stop_level_value and Sset_top_level_value.

[func] ptr Stop_level_value(ptr sym)
[func] void Sset_top_level_value(ptr sym, ptr obj)
These procedures give fast access to the bindings in the original interaction environment and do not reflect changes to the interaction-environment parameter or top-level module imports. To access the current interaction-environment binding for a symbol, it is necessary to call the Scheme top-level-value and set-top-level-value! procedures instead.

Locking Scheme objects.  The storage manager periodically relocates objects in order to reclaim storage and compact the heap. This relocation is completely transparent to Scheme programs, since all pointers to a relocated object are updated to refer to the new location of the object. The storage manager cannot, however, update Scheme pointers that reside outside of the Scheme heap.

As a general rule, all pointers from C variables or data structures to Scheme objects should be discarded before entry (or reentry) into Scheme. That is, if a C procedure receives an object from Scheme or obtains it via the mechanisms described in this section, all pointers to the object should be considered invalid once the C procedure calls into Scheme or returns back to Scheme. Dereferencing an invalid pointer or passing it back to Scheme can have disastrous effects, including unrecoverable memory faults. The foregoing does not apply to immediate objects, e.g., fixnums, characters, booleans, or the empty list. It does apply to all heap-allocated objects, including pairs, vectors, strings, all numbers other than fixnums, ports, procedures, and records.

In practice, the best way to ensure that C code does not retain pointers to Scheme objects is to immediately convert the Scheme objects into C equivalents, if possible. In certain cases, it is not possible to do so, yet retention of the Scheme object is essential to the design of the C portions of the program. In these cases, the object may be locked via the library routine Slock_object (or from Scheme, the equivalent procedure lock-object).

[func] void Slock_object(ptr obj)
Locking an object prevents the storage manager from reclaiming or relocating the object. Locking should be used sparingly, as it introduces memory fragmentation and increases storage management overhead. Locking can also lead to accidental retention of storage if objects are not unlocked. Locking objects that have been made static via heap compaction (see Scompact_heap above) is unnecessary but harmless.

Objects may be unlocked via Sunlock_object (unlock-object).

[func] void Sunlock_object(ptr obj)
An object may be locked more than once by successive calls to Slock_object or lock-object, in which case it must be unlocked by an equal number of calls to Sunlock_object or unlock-object before it is truly unlocked.

The function Sunlocked_objectp can be used to determine if an object is locked.

[func] int Sunlocked_objectp(ptr obj)
When a foreign procedure call is made into Scheme, a return address pointing into the Scheme code object associated with the foreign procedure is passed implicitly to the C routine. The system therefore locks the code object before calls are made from C back into Scheme and unlocks it upon return from Scheme. This locking is performed automatically; user code should never need to lock such code objects.

An object contained within a locked object, such as an object in the car of a locked pair, need not also be locked unless a separate C pointer to the object exists.

Registering foreign entry points.  Foreign entry points may be made visible to Scheme via Sforeign_symbol or Sregister_symbol.

[func] void Sforeign_symbol(const char *name, void *addr)
[func] void Sregister_symbol(const char *name, void *addr)
External entry points in object files or shared objects loaded as a result of a call to load-shared-object are automatically made visible by the system. Once a foreign entry point is made visible, it may be named in a foreign-procedure expression to create a Scheme-callable version of the entry point. Sforeign_symbol and Sregister_symbol allow programs to register nonexternal entry points, entry points in code linked statically with Chez Scheme, and entry points into code loaded directly from C, i.e., without load-shared-object. Sforeign_symbol and Sregister_symbol differ only in that Sforeign_symbol raises an exception when an attempt is made to register an existing name, whereas Sregister_symbol permits existing names to be redefined.

Obtaining Scheme entry points.  Sforeign_callable_entry_point extracts the entry point from a code object produced by foreign-callable, performing the same operation as its Scheme counterpart, i.e., the Scheme procedure foreign-callable-entry-point.

[func] (void (*) (void)) Sforeign_callable_entry_point(ptr code)
This can be used to avoid converting the code object into an address until just when it is needed, which may eliminate the need to lock the code object in some circumstances, assuming that the code object is not saved across any calls back into Scheme.

The inverse translation can be made via Sforeign_callable_code_object.

[func] ptr Sforeign_callable_code_object((void (*addr)(void)))
Low-level support for calls into Scheme.  Support for calling Scheme procedures from C is provided by the set of routines documented below. Calling a Scheme procedure that expects a small number of arguments (0-3) involves the use of one of the following routines.

[func] ptr Scall0(ptr procedure)
[func] ptr Scall1(ptr procedure, ptr obj1)
[func] ptr Scall2(ptr procedure, ptr obj1, ptr obj2)
[func] ptr Scall3(ptr procedure, ptr obj1, ptr obj2, ptr obj3)
In each case, the first argument, procedure, should be a Scheme procedure. The remaining arguments, which should be Scheme objects, are passed to the procedure. The tools described earlier in this section may be used to convert C datatypes into their Scheme equivalents. A program that automatically generates conversion code from declarations that are similar to foreign-procedure expressions is distributed with Chez Scheme. It can be found in the Scheme library directory on most systems in the file "foreign.ss".

A Scheme procedure may be obtained in a number of ways. For example, it may be received as an argument in a call from Scheme into C, obtained via another call to Scheme, extracted from a Scheme data structure, or obtained from the top-level environment via Stop_level_value.

A more general interface involving the following routines is available for longer argument lists.

[func] void Sinitframe(iptr n)
[func] void Sput_arg(iptr i, ptr obj)
[func] ptr Scall(ptr procedure, iptr n)
A C procedure first calls Sinitframe with one argument, the number of arguments to be passed to Scheme. It then calls Sput_arg once for each argument (in any order), passing Sput_arg the argument number (starting with 1) and the argument. Finally, it calls Scall to perform the call, passing it the Scheme procedure and the number of arguments (the same number as in the call to Sinitframe). Programmers should ensure a Scheme call initiated via Sinitframe is completed via Scall before any other calls to Scheme are made and before a return to Scheme is attempted. If for any reason the call is not completed after Sinitframe has been called, it may not be possible to return to Scheme.

The following examples serve to illustrate both the simpler and more general interfaces.

/* a particularly silly way to multiply two floating-point numbers */
double mul(double x, double y) {
    ptr times = Stop_level_value(Sstring_to_symbol("*")); 

    return Sflonum_value(Scall2(times, Sflonum(x), Sflonum(y)));
}

/* an equally silly way to call printf with five arguments */ 

/* it is best to define interfaces such as the one below to handle
 * calls into Scheme to prevent accidental attempts to nest frame
 * creation and to help ensure that initiated calls are completed
 * as discussed above.  Specialized versions tailored to particular
 * C argument types may be defined as well, with embedded conversions
 * to Scheme objects. */
ptr Scall5(ptr p, ptr x1, ptr x2, ptr x3, ptr x4, ptr x5) {
    Sinitframe(5);
    Sput_arg(1, x1);
    Sput_arg(2, x2);
    Sput_arg(3, x3);
    Sput_arg(4, x4);
    Sput_arg(5, x5);
    Scall(p, 5);
} 

static void dumpem(char *s, int a, double b, ptr c, char *d) {
    printf(s, a, b, c, d);
} 

static void foo(int x, double y, ptr z, char *s) {
    ptr ois, sip, read, expr, eval, c_dumpem;
    char *sexpr = "(foreign-procedure \"dumpem\" (string integer-32\
 double-float scheme-object string) void)"; 

  /* this series of statements is carefully crafted to avoid referencing
     variables holding Scheme objects after calls into Scheme */
    ois = Stop_level_value(Sstring_to_symbol("open-input-string"));
    sip = Scall1(ois, Sstring(sexpr));
    read = Stop_level_value(Sstring_to_symbol("read"));
    expr = Scall1(read, sip);
    eval = Stop_level_value(Sstring_to_symbol("eval"));
    Sforeign_symbol("dumpem", (void *)dumpem);
    c_dumpem = Scall1(eval, expr);
    Scall5(c_dumpem,
           Sstring("x = %d, y = %g, z = %x, s = %s\n"),
           Sinteger(x),
           Sflonum(y),
           z,
           Sstring(s));
}

Calls from C to Scheme should not be made from C interrupt handlers. When Scheme calls into C, the system saves the contents of certain dedicated machine registers in a register save area. When C then calls into Scheme, the registers are restored from the register save area. Because an interrupt can occur at any point in a computation, the contents of the register save locations would typically contain invalid information that would cause the Scheme system to fail to operate properly.

Activating, deactivating, and destroying threads.  Three functions are provided by the threaded versions of Scheme to allow C code to notify Scheme when a thread should be activated, deactivated, or destroyed.

[func] int Sactivate_thread(void)
[func] void Sdeactivate_thread(void)
[func] int Sdestroy_thread(void)
A thread created via the Scheme procedure fork-thread starts in the active state and need not be activated. Any thread that has been deactivated, and any thread created by some mechanism other than fork-thread must, however, be activated before it can access Scheme data or execute Scheme code. A foreign callable that is declared with __collect_safe can activate a calling thread. Otherwise, Sactivate_thread must be used to activate a thread. It returns 1 the first time the thread is activated and 0 on each subsequent call until the activation is destroyed with Sdestroy_thread.

Since active threads operating in C code prevent the storage management system from garbage collecting, a thread should be deactivated via Sdeactivate_thread or through a foreign-procedure __collect_safe declaration whenever the thread may spend a significant amount of time in C code. This is especially important whenever the thread calls a C library function, like read, that may block indefinitely. Once deactivated, the thread must not touch any Scheme data or execute any Scheme code until it is reactivated, with one exception. The exception is that the thread may access or even modify a locked Scheme object, such as a locked string, that contains no pointers to other, unlocked Scheme objects. (Objects that are not locked may be relocated by the garbage collector while the thread is inactive.)

Sdestroy_thread is used to notify the Scheme system that the thread is shut down and any thread-specific data can be released.

Low-level synchronization primitives.  The header file defines several preprocessor macros that can be used to lock memory locations in a manner identical to the corresponding ftype lock operations (sections  15.4 and 15.5).

[macro] void INITLOCK(void *addr)
[macro] void SPINLOCK(void *addr)
[macro] void UNLOCK(void *addr)
[macro] void LOCKED_INCR(void *addr, int *ret)
[macro] void LOCKED_DECR(void *addr, int *ret)
LOCKED_INCR and LOCKED_DECR set ret to a nonzero (true) value if the incremented or decremented value is 0. Otherwise they set ret to 0.

###4.9 示例：套接字操作

该节展示了使用Scheme和C代码结合的一个简单的socket接口。C代码定义了一组方便的底层操作系统接口，用于在更高层级的Scheme代码中实现打开，关闭，读取，写入sockets。

C代码（csocket.c）在下面给出，紧接着是Scheme代码（socket.ss）。代码需要很少或者无需修改就能在大多数Unix系统中运行，且可以被修改在windows下运行（使用Windows的WinSock接口）。

代码后面有一个会话例子，展示了socket接口。在9.7中有一个例子，展示了如何使用该socket接口建立一个进程端口，允许通过Scheme端口透明的读取和写入子进程。

**C code.** 

```
/* csocket.c */ 

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h> 

/* c_write attempts to write the entire buffer, pushing through
   interrupts, socket delays, and partial-buffer writes */
int c_write(int fd, char *buf, ssize_t start, ssize_t n) {
    ssize_t i, m; 

    buf += start;
    m = n;
    while (m > 0) {
        if ((i = write(fd, buf, m)) < 0) {
            if (errno != EAGAIN && errno != EINTR)
                return i;
        } else {
            m -= i;
            buf += i;
        }
    }
    return n;
} 

/* c_read pushes through interrupts and socket delays */
int c_read(int fd, char *buf, size_t start, size_t n) {
    int i; 

    buf += start;
    for (;;) {
        i = read(fd, buf, n);
        if (i >= 0) return i;
        if (errno != EAGAIN && errno != EINTR) return -1;
    }
} 

/* bytes_ready(fd) returns true if there are bytes available
   to be read from the socket identified by fd */
int bytes_ready(int fd) {
    int n; 

    (void) ioctl(fd, FIONREAD, &n);
    return n;
} 

/* socket support */ 

/* do_socket() creates a new AF_UNIX socket */
int do_socket(void) { 

    return socket(AF_UNIX, SOCK_STREAM, 0);
} 

/* do_bind(s, name) binds name to the socket s */
int do_bind(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return bind(s, (struct sockaddr*)(&sun), length);
} 

/* do_accept accepts a connection on socket s */
int do_accept(int s) {
    struct sockaddr_un sun;
    socklen_t length; 

    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return accept(s, (struct sockaddr*)(&sun), &length);
} 

/* do_connect initiates a socket connection */
int do_connect(int s, char *name) {
    struct sockaddr_un sun;
    int length; 

    sun.sun_family = AF_UNIX;
    (void) strcpy(sun.sun_path, name);
    length = sizeof(sun.sun_family) + sizeof(sun.sun_path); 

    return connect(s, (struct sockaddr*)(&sun), length);
} 

/* get_error returns the operating system's error status */
char* get_error(void) {
    extern int errno;
    return strerror(errno);
}
```
Scheme code.  

```
;;; socket.ss 

;;; Requires csocket.so, built from csocket.c.
(load-shared-object "./csocket.so") 

;;; Requires from C library:
;;;   close, dup, execl, fork, kill, listen, tmpnam, unlink
(case (machine-type)
  [(i3le ti3le a6le ta6le) (load-shared-object "libc.so.6")]
  [(i3osx ti3osx a6osx ta6osx) (load-shared-object "libc.dylib")]
  [else (load-shared-object "libc.so")]) 

;;; basic C-library stuff 

(define close
  (foreign-procedure "close" (int)
    int)) 

(define dup
  (foreign-procedure "dup" (int)
    int)) 

(define execl4
  (let ((execl-help
         (foreign-procedure "execl"
           (string string string string void*)
           int)))
    (lambda (s1 s2 s3 s4)
      (execl-help s1 s2 s3 s4 0)))) 

(define fork
  (foreign-procedure "fork" ()
    int)) 

(define kill
  (foreign-procedure "kill" (int int)
    int)) 

(define listen
  (foreign-procedure "listen" (int int)
    int)) 

(define tmpnam
  (foreign-procedure "tmpnam" (void*)
    string)) 

(define unlink
  (foreign-procedure "unlink" (string)
    int)) 

;;; routines defined in csocket.c 

(define accept
  (foreign-procedure "do_accept" (int)
    int)) 

(define bytes-ready?
  (foreign-procedure "bytes_ready" (int)
    boolean)) 

(define bind
  (foreign-procedure "do_bind" (int string)
    int)) 

(define c-error
  (foreign-procedure "get_error" ()
    string)) 

(define c-read
  (foreign-procedure "c_read" (int u8* size_t size_t)
    ssize_t)) 

(define c-write
  (foreign-procedure "c_write" (int u8* size_t ssize_t)
    ssize_t)) 

(define connect
  (foreign-procedure "do_connect" (int string)
    int)) 

(define socket
  (foreign-procedure "do_socket" ()
    int)) 

;;; higher-level routines 

(define dodup
 ; (dodup old new) closes old and dups new, then checks to
 ; make sure that resulting fd is the same as old
  (lambda (old new)
    (check 'close (close old))
    (unless (= (dup new) old)
      (error 'dodup
        "couldn't set up child process io for fd ~s" old)))) 

(define dofork
 ; (dofork child parent) forks a child process and invokes child
 ; without arguments and parent with the child's pid
  (lambda (child parent)
    (let ([pid (fork)])
      (cond
        [(= pid 0) (child)]
        [(> pid 0) (parent pid)]
        [else (error 'fork (c-error))])))) 

(define setup-server-socket
 ; create a socket, bind it to name, and listen for connections
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (unlink name)
      (check 'bind (bind sock name))
      (check 'listen (listen sock 1))
      sock))) 

(define setup-client-socket
 ; create a socket and attempt to connect to server
  (lambda (name)
    (let ([sock (check 'socket (socket))])
      (check 'connect (connect sock name))
      sock))) 

(define accept-socket
 ; accept a connection
  (lambda (sock)
    (check 'accept (accept sock)))) 

(define check
 ; signal an error if status x is negative, using c-error to
 ; obtain the operating-system's error message
  (lambda (who x)
    (if (< x 0)
        (error who (c-error))
        x))) 

(define terminate-process
 ; kill the process identified by pid
  (lambda (pid)
    (define sigterm 15)
    (kill pid sigterm)
    (void)))
```

**Sample session. **

```
> (define client-pid)
> (define client-socket)
> (let* ([server-socket-name (tmpnam 0)]
         [server-socket (setup-server-socket server-socket-name)])
   ; fork a child, use it to exec a client Scheme process, and set
   ; up server-side client-pid and client-socket variables.
    (dofork   ; child
      (lambda () 
       ; the child establishes the socket input/output fds as
       ; stdin and stdout, then starts a new Scheme session
        (check 'close (close server-socket))
        (let ([sock (setup-client-socket server-socket-name)])
          (dodup 0 sock)
          (dodup 1 sock))
        (check 'execl (execl4 "/bin/sh" "/bin/sh" "-c" "exec scheme -q"))
        (errorf 'client "returned!"))
      (lambda (pid) ; parent
       ; the parent waits for a connection from the client
        (set! client-pid pid)
        (set! client-socket (accept-socket server-socket))
        (check 'close (close server-socket)))))
> (define put ; procedure to send data to client
    (lambda (x)
      (let ([s (format "~s~%" x)])
        (c-write client-socket s (string-length s)))
      (void)))
> (define get ; procedure to read data from client
    (let ([buff (make-string 1024)])
      (lambda ()
        (let ([n (c-read client-socket buff (string-length buff))])
          (printf "client:~%~a~%server:~%" (substring buff 0 n))))))
> (get)
server:
> (put '(let ([x 3]) x))
> (get)
client:
3
server:
> (terminate-process client-pid)
> (exit)
```

---
Chez Scheme Version 9 User's Guide
Copyright © 2018 Cisco Systems, Inc.
Licensed under the [Apache License Version 2.0](http://www.apache.org/licenses/LICENSE-2.0) ([full copyright notice.](https://cisco.github.io/ChezScheme/csug9.5/canned/copyright.html)).
Revised October 2018 for Chez Scheme Version 9.5.1
[about this book](https://cisco.github.io/ChezScheme/csug9.5/canned/about.html)
